

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  DELETE FROM public.oto_offers
  WHERE source_product_id = source_product_id_param;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RETURN jsonb_build_object(
    'success', true,
    'deleted', deleted_count
  );
END;
$$;


ALTER FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") IS 'Delete OTO offer for a product (admin only)';



CREATE OR REPLACE FUNCTION "public"."admin_get_product_order_bumps"("product_id_param" "uuid") RETURNS TABLE("bump_id" "uuid", "bump_product_id" "uuid", "bump_product_name" "text", "bump_price" numeric, "bump_title" "text", "bump_description" "text", "is_active" boolean, "display_order" integer, "access_duration_days" integer, "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  RETURN QUERY
  SELECT
    ob.id as bump_id,
    ob.bump_product_id,
    p.name as bump_product_name,
    ob.bump_price,
    ob.bump_title,
    ob.bump_description,
    ob.is_active,
    ob.display_order,
    ob.access_duration_days,
    ob.created_at,
    ob.updated_at
  FROM public.order_bumps ob
  INNER JOIN public.products p ON p.id = ob.bump_product_id
  WHERE ob.main_product_id = product_id_param
  ORDER BY ob.display_order ASC, ob.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."admin_get_product_order_bumps"("product_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  oto_record RECORD;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Get OTO offer for this product
  SELECT
    o.*,
    p.name as oto_product_name,
    p.slug as oto_product_slug,
    p.price as oto_product_price,
    p.currency as oto_product_currency
  INTO oto_record
  FROM public.oto_offers o
  INNER JOIN public.products p ON p.id = o.oto_product_id
  WHERE o.source_product_id = product_id_param
  ORDER BY o.display_order ASC
  LIMIT 1;

  IF oto_record IS NULL THEN
    RETURN jsonb_build_object('has_oto', false);
  END IF;

  RETURN jsonb_build_object(
    'has_oto', true,
    'id', oto_record.id,
    'oto_product_id', oto_record.oto_product_id,
    'oto_product_name', oto_record.oto_product_name,
    'oto_product_slug', oto_record.oto_product_slug,
    'oto_product_price', oto_record.oto_product_price,
    'oto_product_currency', oto_record.oto_product_currency,
    'discount_type', oto_record.discount_type,
    'discount_value', oto_record.discount_value,
    'duration_minutes', oto_record.duration_minutes,
    'is_active', oto_record.is_active
  );
END;
$$;


ALTER FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") IS 'Get OTO configuration for a product (admin only)';



CREATE OR REPLACE FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer DEFAULT 15, "is_active_param" boolean DEFAULT true) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  result_id UUID;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Validate inputs
  IF source_product_id_param = oto_product_id_param THEN
    RETURN jsonb_build_object('success', false, 'error', 'Source and OTO product cannot be the same');
  END IF;

  IF discount_type_param NOT IN ('percentage', 'fixed') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid discount type');
  END IF;

  IF discount_type_param = 'percentage' AND discount_value_param > 100 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Percentage discount cannot exceed 100%');
  END IF;

  IF duration_minutes_param < 1 OR duration_minutes_param > 1440 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Duration must be between 1 and 1440 minutes');
  END IF;

  -- Upsert OTO offer
  INSERT INTO public.oto_offers (
    source_product_id,
    oto_product_id,
    discount_type,
    discount_value,
    duration_minutes,
    is_active
  ) VALUES (
    source_product_id_param,
    oto_product_id_param,
    discount_type_param,
    discount_value_param,
    duration_minutes_param,
    is_active_param
  )
  ON CONFLICT (source_product_id, oto_product_id) DO UPDATE SET
    discount_type = EXCLUDED.discount_type,
    discount_value = EXCLUDED.discount_value,
    duration_minutes = EXCLUDED.duration_minutes,
    is_active = EXCLUDED.is_active,
    updated_at = NOW()
  RETURNING id INTO result_id;

  RETURN jsonb_build_object(
    'success', true,
    'id', result_id
  );
END;
$$;


ALTER FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer, "is_active_param" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer, "is_active_param" boolean) IS 'Create or update OTO offer for a product (admin only)';



CREATE OR REPLACE FUNCTION "public"."audit_trigger_function"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log (table_name, operation, old_values, user_id)
    VALUES (TG_TABLE_NAME, TG_OP, row_to_json(OLD), auth.uid());
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_log (table_name, operation, old_values, new_values, user_id)
    VALUES (TG_TABLE_NAME, TG_OP, row_to_json(OLD), row_to_json(NEW), auth.uid());
    RETURN NEW;
  ELSIF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log (table_name, operation, new_values, user_id)
    VALUES (TG_TABLE_NAME, TG_OP, row_to_json(NEW), auth.uid());
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."audit_trigger_function"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    result JSONB := '{}';
    slug TEXT;
    has_access BOOLEAN;
    current_user_id UUID;
    clean_slug TEXT;
    safe_key TEXT;
BEGIN
    -- Rate limiting: 200 calls per hour per user (increased for checkout)
    IF NOT public.check_rate_limit('batch_check_user_product_access'::TEXT, 200, 3600) THEN
        RAISE EXCEPTION 'Rate limit exceeded for batch_check_user_product_access';
    END IF;

    -- Input validation
    IF product_slugs_param IS NULL OR array_length(product_slugs_param, 1) IS NULL THEN
        RETURN result;
    END IF;
    
    -- Limit array size to prevent DoS attacks (reduced from 50 to 20)
    IF array_length(product_slugs_param, 1) > 20 THEN
        RAISE EXCEPTION 'Too many product slugs requested (maximum 20)';
    END IF;
    
    -- Get current authenticated user ID
    current_user_id := auth.uid();
    IF current_user_id IS NULL THEN
        RETURN result;
    END IF;
    
    -- Check access for each product slug with proper sanitization
    FOREACH slug IN ARRAY product_slugs_param
    LOOP
        -- Validate input length first
        IF slug IS NULL OR length(slug) = 0 OR length(slug) > 100 THEN
            CONTINUE; -- Skip invalid slugs completely
        END IF;
        
        -- Sanitize slug: only allow alphanumeric, hyphens, and underscores
        clean_slug := regexp_replace(slug, '[^a-zA-Z0-9_-]', '', 'g');
        
        -- Skip empty or invalid slugs after sanitization
        IF clean_slug IS NULL OR length(clean_slug) = 0 THEN
            CONTINUE;
        END IF;
        
        -- Create safe JSON key (use clean_slug for both query and key)
        safe_key := clean_slug;
        
        -- Use parameterized query to prevent SQL injection
        -- NOTE: is_active controls product visibility for NEW purchases only
        -- Users who already have access keep it regardless of is_active status
        SELECT EXISTS (
            SELECT 1
            FROM public.user_product_access upa
            JOIN public.products p ON upa.product_id = p.id
            WHERE upa.user_id = current_user_id
              AND p.slug = clean_slug
              -- Check temporal access for user (only condition that revokes access)
              AND (upa.access_expires_at IS NULL OR upa.access_expires_at >= NOW())
        ) INTO has_access;
        
        -- Use sanitized key for JSON to prevent injection
        result := result || jsonb_build_object(safe_key, has_access);
    END LOOP;
    
    RETURN result;
END;
$$;


ALTER FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) IS 'Batch check user access for multiple products. Limited to 20 products per call with rate limiting.';



CREATE OR REPLACE FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  window_start_param TIMESTAMPTZ;
  current_count INTEGER;
BEGIN
  -- Input validation
  IF identifier_param IS NULL OR length(identifier_param) = 0 OR length(identifier_param) > 200 THEN
    RETURN FALSE;
  END IF;

  IF action_type_param IS NULL OR length(action_type_param) = 0 OR length(action_type_param) > 100 THEN
    RETURN FALSE;
  END IF;

  -- Calculate window start (round down to window boundary)
  window_start_param := date_trunc('hour', NOW()) +
                       INTERVAL '1 minute' * (FLOOR(EXTRACT(EPOCH FROM (NOW() - date_trunc('hour', NOW()))) / 60 / window_minutes) * window_minutes);

  -- Try to increment existing record or insert new one
  INSERT INTO public.application_rate_limits (identifier, action_type, window_start, call_count)
  VALUES (identifier_param, action_type_param, window_start_param, 1)
  ON CONFLICT (identifier, action_type, window_start)
  DO UPDATE SET
    call_count = application_rate_limits.call_count + 1,
    updated_at = NOW()
  RETURNING application_rate_limits.call_count INTO current_count;

  -- Check if we're over the limit
  RETURN current_count <= max_requests;
END;
$$;


ALTER FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) IS 'Application-level rate limiting for Next.js API routes. Use this from /lib/rate-limiting.ts';



CREATE OR REPLACE FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer DEFAULT 100, "time_window_seconds" integer DEFAULT 3600) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    current_user_id UUID;
    window_start_param TIMESTAMPTZ;
    current_count INTEGER;
    client_ip TEXT;
    rate_limit_key TEXT;
    backup_rate_limit_key TEXT;
    backup_count INTEGER;
BEGIN
    -- Input validation
    IF function_name_param IS NULL OR length(function_name_param) = 0 OR length(function_name_param) > 100 THEN
        RETURN FALSE;
    END IF;
    
    -- Get current user ID
    current_user_id := auth.uid();
    
    -- Calculate window start (round down to nearest window) - moved here to avoid conflicts
    window_start_param := date_trunc('hour', NOW()) + 
                   INTERVAL '1 second' * (FLOOR(EXTRACT(EPOCH FROM NOW() - date_trunc('hour', NOW())) / time_window_seconds) * time_window_seconds);
    
    -- For anonymous users, use SECURE rate limiting to prevent bypass attacks (CRITICAL SECURITY FIX)
    IF current_user_id IS NULL THEN
        -- SECURITY: Never trust client headers - they can be easily spoofed!
        -- Use only server-side reliable sources for rate limiting
        client_ip := COALESCE(
            -- Only use inet_client_addr() which comes from actual TCP connection
            inet_client_addr()::text,
            -- Fallback to connection-based identifier that can't be spoofed
            'conn_' || pg_backend_pid()::text || '_' || extract(epoch from NOW())::bigint::text
        );
        
        -- Enhanced protection: Multiple layers of rate limiting for anonymous users
        -- Layer 1: Connection-based (primary)
        rate_limit_key := 'anon_conn_' || 
                         regexp_replace(client_ip, '[^0-9.]', '', 'g') || '_' || 
                         function_name_param;
        
        -- Layer 2: Add session entropy to prevent easy bypass
        -- Use JWT sub claim if available (can't be spoofed easily)
        IF current_setting('request.jwt.claims', true) != '' THEN
            rate_limit_key := rate_limit_key || '_' || 
                             COALESCE(
                                 current_setting('request.jwt.claims', true)::jsonb->>'sub',
                                 current_setting('request.jwt.claims', true)::jsonb->>'aud',
                                 'no_jwt'
                             );
        ELSE
            -- No JWT available - use time-based bucket to prevent complete bypass
            rate_limit_key := rate_limit_key || '_bucket_' || 
                             FLOOR(extract(epoch from NOW()) / 300)::text; -- 5-minute buckets
        END IF;
        
        -- Create deterministic UUID from rate_limit_key using MD5 hash
        current_user_id := (md5(rate_limit_key)::uuid);
        
        -- BACKUP RATE LIMITING: Global anonymous protection (CRITICAL)
        -- This prevents mass attacks even if primary rate limiting is bypassed
        backup_rate_limit_key := 'global_anon_' || function_name_param;
        
        -- Check global anonymous rate limit (stricter limits)
        INSERT INTO public.rate_limits (user_id, function_name, window_start, call_count)
        VALUES (
            (md5(backup_rate_limit_key)::uuid), -- Deterministic UUID from backup key
            'global_' || function_name_param, 
            window_start_param, -- Use the calculated window_start_param variable
            1
        )
        ON CONFLICT (user_id, function_name, window_start)
        DO UPDATE SET 
            call_count = rate_limits.call_count + 1,
            updated_at = NOW()
        RETURNING rate_limits.call_count INTO backup_count;
        IF backup_count > GREATEST(10, max_calls * 2) THEN -- Global limit is 200% of individual limit, minimum 10
            RETURN FALSE;
        END IF;
    END IF;
    
    -- Try to increment existing record or insert new one
    INSERT INTO public.rate_limits (user_id, function_name, window_start, call_count)
    VALUES (current_user_id, function_name_param, window_start_param, 1)
    ON CONFLICT (user_id, function_name, window_start)
    DO UPDATE SET 
        call_count = rate_limits.call_count + 1,
        updated_at = NOW()
    RETURNING rate_limits.call_count INTO current_count;
    
    -- Check if we're over the limit
    RETURN current_count <= max_calls;
END;
$$;


ALTER FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer, "time_window_seconds" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer, "time_window_seconds" integer) IS 'SECURE rate limiting function with anti-spoofing protection. CRITICAL: Never trust client headers like x-forwarded-for as they can be easily spoofed by attackers to bypass rate limits. Uses only server-side reliable sources.';



CREATE OR REPLACE FUNCTION "public"."check_refund_eligibility"("transaction_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '5s'
    AS $$
DECLARE
    transaction_record RECORD;
    days_since_purchase INTEGER;
    existing_request RECORD;
BEGIN
    -- Get transaction details with product info
    SELECT pt.*, p.is_refundable, p.refund_period_days, p.name as product_name
    INTO transaction_record
    FROM public.payment_transactions pt
    JOIN public.products p ON pt.product_id = p.id
    WHERE pt.id = transaction_id_param;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('eligible', false, 'reason', 'transaction_not_found');
    END IF;

    IF transaction_record.status = 'refunded' THEN
        RETURN jsonb_build_object('eligible', false, 'reason', 'already_refunded');
    END IF;

    IF NOT transaction_record.is_refundable THEN
        RETURN jsonb_build_object('eligible', false, 'reason', 'product_not_refundable');
    END IF;

    -- Check for existing pending request
    SELECT * INTO existing_request
    FROM public.refund_requests
    WHERE refund_requests.transaction_id = transaction_id_param
      AND status IN ('pending', 'approved');

    IF FOUND THEN
        RETURN jsonb_build_object(
            'eligible', false,
            'reason', 'request_already_exists',
            'existing_request_id', existing_request.id,
            'existing_request_status', existing_request.status
        );
    END IF;

    -- Calculate days since purchase
    days_since_purchase := EXTRACT(DAY FROM NOW() - transaction_record.created_at);

    -- Check refund period
    IF transaction_record.refund_period_days IS NOT NULL AND
       days_since_purchase > transaction_record.refund_period_days THEN
        RETURN jsonb_build_object(
            'eligible', false,
            'reason', 'refund_period_expired',
            'refund_period_days', transaction_record.refund_period_days,
            'days_since_purchase', days_since_purchase
        );
    END IF;

    -- Transaction is eligible
    RETURN jsonb_build_object(
        'eligible', true,
        'transaction_id', transaction_record.id,
        'product_name', transaction_record.product_name,
        'amount', transaction_record.amount,
        'currency', transaction_record.currency,
        'refund_period_days', transaction_record.refund_period_days,
        'days_since_purchase', days_since_purchase,
        'days_remaining', CASE
            WHEN transaction_record.refund_period_days IS NOT NULL
            THEN transaction_record.refund_period_days - days_since_purchase
            ELSE NULL
        END
    );
END;
$$;


ALTER FUNCTION "public"."check_refund_eligibility"("transaction_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_user_product_access"("product_slug_param" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    clean_slug TEXT;
BEGIN
    -- Rate limiting: 1000 calls per hour per user (increased for checkout)
    IF NOT public.check_rate_limit('check_user_product_access'::TEXT, 1000, 3600) THEN
        RAISE EXCEPTION 'Rate limit exceeded for check_user_product_access';
    END IF;

    -- Input validation and sanitization
    IF product_slug_param IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Sanitize slug: only allow alphanumeric, hyphens, and underscores
    clean_slug := regexp_replace(product_slug_param, '[^a-zA-Z0-9_-]', '', 'g');
    
    -- Validate sanitized slug
    IF clean_slug IS NULL OR length(clean_slug) = 0 OR length(clean_slug) > 100 THEN
        RETURN FALSE;
    END IF;
    
    -- Get current authenticated user ID
    IF auth.uid() IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- NOTE: is_active controls product visibility for NEW purchases only
    -- Users who already have access keep it regardless of is_active status
    -- Access is revoked only when: product is deleted OR access_expires_at passes
    RETURN EXISTS (
        SELECT 1
        FROM public.user_product_access upa
        JOIN public.products p ON upa.product_id = p.id
        WHERE upa.user_id = auth.uid()  -- Use authenticated user ID
          AND p.slug = clean_slug       -- Use sanitized slug
          -- Check temporal access for user (only condition that revokes access)
          AND (upa.access_expires_at IS NULL OR upa.access_expires_at >= NOW())
    );
END;
$$;


ALTER FUNCTION "public"."check_user_product_access"("product_slug_param" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_user_product_access"("product_slug_param" "text") IS 'Check if authenticated user has access to a specific product by slug. Includes rate limiting and input sanitization.';



CREATE OR REPLACE FUNCTION "public"."check_waitlist_config"() RETURNS json
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  SELECT json_build_object(
    'has_webhook', EXISTS(
      SELECT 1 FROM public.webhook_endpoints
      WHERE 'waitlist.signup' = ANY(events)
        AND is_active = true
    ),
    'products_count', (
      SELECT COUNT(*)::integer
      FROM public.products
      WHERE enable_waitlist = true
    )
  );
$$;


ALTER FUNCTION "public"."check_waitlist_config"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_waitlist_config"() IS 'Check if waitlist.signup webhook exists and count products with waitlist enabled. Used for admin warnings.';



CREATE OR REPLACE FUNCTION "public"."claim_guest_purchases_for_user"("p_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '5s'
    AS $$
DECLARE
  user_email_var TEXT;
  claimed_count INTEGER := 0;
  guest_purchase_record RECORD;
BEGIN
  -- Rate limiting: 10 calls per hour for claiming purchases (SECURITY)
  IF NOT public.check_rate_limit('claim_guest_purchases_for_user', 10, 3600) THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Rate limit exceeded. Please wait before trying again.'
    );
  END IF;

  -- Input validation
  IF p_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'User ID is required'
    );
  END IF;
  
  -- Get user's email using parameterized query (SECURITY)
  SELECT email INTO user_email_var 
  FROM auth.users 
  WHERE id = p_user_id;
  
  IF user_email_var IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'User not found'
    );
  END IF;
  
  -- Enhanced email format validation using dedicated function
  IF NOT public.validate_email_format(user_email_var) THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Invalid email format'
    );
  END IF;
  
  -- Find and claim all unclaimed guest purchases for this email
  -- Direct query - no need for dynamic SQL (SECURITY FIX)
  FOR guest_purchase_record IN
    SELECT * FROM public.guest_purchases 
    WHERE customer_email = user_email_var 
      AND claimed_by_user_id IS NULL
  LOOP
    -- Update guest purchase to mark as claimed
    UPDATE public.guest_purchases
    SET claimed_by_user_id = p_user_id,
        claimed_at = NOW()
    WHERE id = guest_purchase_record.id;
    
    -- Grant access to the product using optimistic locking with error handling
    BEGIN
      DECLARE
        grant_result JSONB;
      BEGIN
        SELECT public.grant_product_access_service_role(p_user_id, guest_purchase_record.product_id) INTO grant_result;
        
        IF (grant_result->>'success')::boolean = true THEN
          claimed_count := claimed_count + 1;
        ELSE
          -- Handle optimistic locking failures
          IF (grant_result->>'retry_exceeded')::boolean = true THEN
            -- High concurrency - log and continue
            PERFORM public.log_admin_action(
              'guest_claim_concurrency_failure',
              'guest_purchases',
              guest_purchase_record.id::TEXT,
              jsonb_build_object(
                'severity', 'WARNING',
                'error_type', 'optimistic_lock_retry_exceeded',
                'user_id', p_user_id,
                'product_id', guest_purchase_record.product_id,
                'guest_purchase_id', guest_purchase_record.id,
                'grant_result', grant_result,
                'function_name', 'claim_guest_purchases_for_user',
                'timestamp', extract(epoch from NOW()),
                'context', 'guest_claim_processing'
              )
            );
          ELSE
            -- Other error
            PERFORM public.log_admin_action(
              'guest_claim_grant_failure',
              'guest_purchases',
              guest_purchase_record.id::TEXT,
              jsonb_build_object(
                'severity', 'ERROR',
                'error_type', 'access_grant_failure',
                'user_id', p_user_id,
                'product_id', guest_purchase_record.product_id,
                'guest_purchase_id', guest_purchase_record.id,
                'grant_result', grant_result,
                'function_name', 'claim_guest_purchases_for_user',
                'timestamp', extract(epoch from NOW()),
                'context', 'guest_claim_processing'
              )
            );
          END IF;
          
          -- Roll back the claim update since access grant failed
          UPDATE public.guest_purchases
          SET claimed_by_user_id = NULL,
              claimed_at = NULL
          WHERE id = guest_purchase_record.id;
        END IF;
      END;
    EXCEPTION 
      WHEN OTHERS THEN
        -- Critical error: guest purchase marked as claimed but access not granted
        PERFORM public.log_admin_action(
          'critical_guest_claim_failure',
          'guest_purchases',
          guest_purchase_record.id::TEXT,
          jsonb_build_object(
            'severity', 'CRITICAL',
            'error_type', 'guest_claim_exception',
            'error_code', SQLSTATE,
            'error_message', SQLERRM,
            'user_id', p_user_id,
            'product_id', guest_purchase_record.product_id,
            'guest_purchase_id', guest_purchase_record.id,
            'function_name', 'claim_guest_purchases_for_user',
            'timestamp', extract(epoch from NOW()),
            'context', 'guest_claim_processing'
          )
        );
        
        -- Roll back the claim update since access grant failed
        UPDATE public.guest_purchases
        SET claimed_by_user_id = NULL,
            claimed_at = NULL
        WHERE id = guest_purchase_record.id;
        
        -- Continue with other purchases but log the failure
        NULL;
    END;
  END LOOP;
  
  RETURN json_build_object(
    'success', true,
    'claimed_count', claimed_count,
    'message', 'Claimed ' || claimed_count || ' guest purchases'
  );
END;
$$;


ALTER FUNCTION "public"."claim_guest_purchases_for_user"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_application_rate_limits"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete entries older than 24 hours
  DELETE FROM public.application_rate_limits
  WHERE window_start < NOW() - INTERVAL '24 hours';

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_application_rate_limits"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_application_rate_limits"() IS 'Cleanup old application rate limit entries (run via cron job)';



CREATE OR REPLACE FUNCTION "public"."cleanup_audit_logs"("retention_days" integer DEFAULT 90) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Input validation
    IF retention_days < 1 OR retention_days > 3650 THEN
        RAISE EXCEPTION 'Retention days must be between 1 and 3650';
    END IF;
    
    -- Delete audit log records older than retention period
    DELETE FROM public.audit_log
    WHERE performed_at < NOW() - INTERVAL '1 day' * retention_days;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_audit_logs"("retention_days" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_audit_logs"("retention_days" integer) IS 'Cleanup old audit log records based on retention policy. Default is 90 days.';



CREATE OR REPLACE FUNCTION "public"."cleanup_expired_oto_coupons"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete OTO coupons that:
  -- 1. Are OTO coupons
  -- 2. Expired more than 1 hour ago (grace period)
  -- 3. Were never used
  DELETE FROM public.coupons
  WHERE is_oto_coupon = true
    AND expires_at < NOW() - INTERVAL '1 hour'
    AND current_usage_count = 0;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  -- Optional: Log cleanup
  -- RAISE NOTICE 'Cleaned up % expired OTO coupons', deleted_count;

  RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_oto_coupons"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_expired_oto_coupons"() IS 'Cleanup function for expired OTO coupons - call via pg_cron or external trigger';



CREATE OR REPLACE FUNCTION "public"."cleanup_old_admin_actions"("retention_days" integer DEFAULT 90) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '30s'
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Security check: only admins can cleanup audit logs
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        RAISE EXCEPTION 'Unauthorized: Admin privileges required';
    END IF;
    
    -- Input validation
    IF retention_days IS NULL OR retention_days < 30 THEN
        RAISE EXCEPTION 'Retention period must be at least 30 days';
    END IF;
    
    -- Delete old admin actions
    DELETE FROM public.admin_actions 
    WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- VACUUM workaround: Reset statistics to encourage autovacuum after bulk deletion
    -- Note: This is a safe workaround since we can't execute VACUUM directly in functions
    -- PostgreSQL autovacuum will handle actual space reclamation based on updated statistics
    IF deleted_count > 100 THEN
        -- Check dead tuple count and reset statistics if significant cleanup is needed
        IF (SELECT n_dead_tup FROM pg_stat_user_tables WHERE relname = 'admin_actions') > 1000 THEN
            -- Reset statistics to encourage autovacuum daemon to process this table
            PERFORM pg_stat_reset_single_table_counters('admin_actions'::regclass);
        END IF;
    END IF;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_admin_actions"("retention_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_old_guest_purchases"("retention_days" integer DEFAULT 365) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '30s'
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Security check: only admins can cleanup guest purchases
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        RAISE EXCEPTION 'Unauthorized: Admin privileges required';
    END IF;
    
    -- Input validation
    IF retention_days IS NULL OR retention_days < 30 THEN
        RAISE EXCEPTION 'Retention period must be at least 30 days';
    END IF;
    
    -- Delete old claimed guest purchases (leverages BRIN index for efficiency)
    -- Only delete claimed purchases to preserve unclaimed ones
    DELETE FROM public.guest_purchases 
    WHERE claimed_at IS NOT NULL 
      AND claimed_at < NOW() - (retention_days || ' days')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- VACUUM workaround: Reset statistics to encourage autovacuum after bulk deletion
    -- Note: This is a safe workaround since we can't execute VACUUM directly in functions
    -- PostgreSQL autovacuum will handle actual space reclamation based on updated statistics
    IF deleted_count > 100 THEN
        -- Check dead tuple count and reset statistics if significant cleanup is needed
        IF (SELECT n_dead_tup FROM pg_stat_user_tables WHERE relname = 'guest_purchases') > 1000 THEN
            -- Reset statistics to encourage autovacuum daemon to process this table
            PERFORM pg_stat_reset_single_table_counters('guest_purchases'::regclass);
        END IF;
    END IF;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_guest_purchases"("retention_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_old_price_history"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Delete price history entries older than 30 days
  DELETE FROM product_price_history
  WHERE effective_from < NOW() - INTERVAL '30 days'
    AND effective_until IS NOT NULL; -- Only delete closed periods, keep current price

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_price_history"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_old_price_history"() IS 'Automatically removes price history entries older than 30 days to comply with Omnibus Directive requirements';



CREATE OR REPLACE FUNCTION "public"."cleanup_old_rate_limits"("retention_hours" integer DEFAULT 24) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '60s'
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Security check: only admins can cleanup rate limits
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        RAISE EXCEPTION 'Unauthorized: Admin privileges required';
    END IF;
    
    -- Input validation
    IF retention_hours IS NULL OR retention_hours < 1 THEN
        RAISE EXCEPTION 'Retention period must be at least 1 hour';
    END IF;
    
    -- Delete old rate limit records (leverages BRIN index for efficiency)
    DELETE FROM public.rate_limits 
    WHERE window_start < NOW() - (retention_hours || ' hours')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- VACUUM workaround: Reset statistics to encourage autovacuum after bulk deletion
    -- Note: This is a safe workaround since we can't execute VACUUM directly in functions
    -- PostgreSQL autovacuum will handle actual space reclamation based on updated statistics
    IF deleted_count > 1000 THEN
        -- Check dead tuple count and reset statistics if significant cleanup is needed
        IF (SELECT n_dead_tup FROM pg_stat_user_tables WHERE relname = 'rate_limits') > 5000 THEN
            -- Reset statistics to encourage autovacuum daemon to process this table
            PERFORM pg_stat_reset_single_table_counters('rate_limits'::regclass);
        END IF;
    END IF;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_rate_limits"("retention_hours" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_rate_limits"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Delete rate limit records older than 24 hours
    DELETE FROM public.rate_limits
    WHERE window_start < NOW() - INTERVAL '24 hours';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_rate_limits"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_rate_limits"() IS 'Cleanup old rate limit records. Should be called periodically (e.g., daily cron job).';



CREATE OR REPLACE FUNCTION "public"."clear_admin_cache"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    current_user_id UUID;
    cache_key TEXT;
BEGIN
    -- Get current authenticated user
    current_user_id := (SELECT auth.uid());
    IF current_user_id IS NOT NULL THEN
        -- Clear the session-specific cache
        cache_key := 'app.user_is_admin_' || replace(current_user_id::TEXT, '-', '_');
        PERFORM set_config(cache_key, NULL, false);
    END IF;
END;
$$;


ALTER FUNCTION "public"."clear_admin_cache"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_refund_request"("transaction_id_param" "uuid", "reason_param" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $$
DECLARE
    current_user_id UUID;
    transaction_record RECORD;
    eligibility JSONB;
    new_request_id UUID;
BEGIN
    -- Rate limiting
    IF NOT public.check_rate_limit('create_refund_request', 10, 3600) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Rate limit exceeded. Please try again later.');
    END IF;

    current_user_id := auth.uid();

    IF current_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Authentication required');
    END IF;

    -- Check eligibility first
    eligibility := public.check_refund_eligibility(transaction_id_param);

    IF NOT (eligibility->>'eligible')::boolean THEN
        RETURN jsonb_build_object('success', false, 'error', eligibility->>'reason', 'details', eligibility);
    END IF;

    -- Get transaction for ownership check
    SELECT pt.*, p.name as product_name
    INTO transaction_record
    FROM public.payment_transactions pt
    JOIN public.products p ON pt.product_id = p.id
    WHERE pt.id = transaction_id_param;

    -- Verify ownership
    IF transaction_record.user_id != current_user_id THEN
        RETURN jsonb_build_object('success', false, 'error', 'You can only request refunds for your own purchases');
    END IF;

    -- Create the refund request
    INSERT INTO public.refund_requests (
        transaction_id, user_id, customer_email, product_id, reason,
        requested_amount, currency, status
    ) VALUES (
        transaction_id_param, current_user_id, transaction_record.customer_email,
        transaction_record.product_id, reason_param,
        transaction_record.amount - COALESCE(transaction_record.refunded_amount, 0),
        transaction_record.currency, 'pending'
    )
    RETURNING id INTO new_request_id;

    RETURN jsonb_build_object(
        'success', true,
        'request_id', new_request_id,
        'status', 'pending',
        'message', 'Refund request submitted successfully'
    );

EXCEPTION WHEN unique_violation THEN
    RETURN jsonb_build_object('success', false, 'error', 'A refund request already exists for this transaction');
END;
$$;


ALTER FUNCTION "public"."create_refund_request"("transaction_id_param" "uuid", "reason_param" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_auto_apply_coupon"("customer_email_param" "text", "product_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  coupon_record RECORD;
BEGIN
  -- SECURITY FIX: Add FOR UPDATE SKIP LOCKED to prevent race conditions
  SELECT * INTO coupon_record
  FROM public.coupons
  WHERE is_active = true
    AND (allowed_emails @> to_jsonb(customer_email_param))
    AND (
      jsonb_array_length(allowed_product_ids) = 0 OR
      allowed_product_ids @> to_jsonb(product_id_param)
    )
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (starts_at <= NOW())
    AND (usage_limit_global IS NULL OR current_usage_count < usage_limit_global)
  ORDER BY created_at DESC
  LIMIT 1
  FOR UPDATE SKIP LOCKED;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('found', false);
  END IF;

  RETURN jsonb_build_object(
    'found', true,
    'code', coupon_record.code,
    'discount_type', coupon_record.discount_type,
    'discount_value', coupon_record.discount_value,
    'exclude_order_bumps', coupon_record.exclude_order_bumps
  );
END;
$$;


ALTER FUNCTION "public"."find_auto_apply_coupon"("customer_email_param" "text", "product_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  oto_config RECORD;
  oto_product RECORD;
  existing_coupon RECORD;
  new_coupon_code TEXT;
  new_coupon_id UUID;
  coupon_expires_at TIMESTAMPTZ;
BEGIN
  -- IDEMPOTENCY CHECK: Check if OTO coupon already exists for this transaction
  SELECT c.id, c.code, c.discount_type, c.discount_value, c.expires_at,
         o.oto_product_id, p.slug as oto_product_slug, p.name as oto_product_name,
         p.price as oto_product_price, p.currency as oto_product_currency,
         o.duration_minutes
  INTO existing_coupon
  FROM public.coupons c
  INNER JOIN public.oto_offers o ON c.oto_offer_id = o.id
  INNER JOIN public.products p ON o.oto_product_id = p.id
  WHERE c.source_transaction_id = transaction_id_param
    AND c.is_oto_coupon = true
  LIMIT 1;

  -- If coupon already exists for this transaction, return existing info
  IF existing_coupon IS NOT NULL THEN
    RETURN jsonb_build_object(
      'has_oto', true,
      'coupon_code', existing_coupon.code,
      'coupon_id', existing_coupon.id,
      'oto_product_id', existing_coupon.oto_product_id,
      'oto_product_slug', existing_coupon.oto_product_slug,
      'oto_product_name', existing_coupon.oto_product_name,
      'oto_product_price', existing_coupon.oto_product_price,
      'oto_product_currency', existing_coupon.oto_product_currency,
      'discount_type', existing_coupon.discount_type,
      'discount_value', existing_coupon.discount_value,
      'expires_at', existing_coupon.expires_at,
      'duration_minutes', existing_coupon.duration_minutes
    );
  END IF;

  -- Find active OTO offer for this product
  SELECT o.*, p.slug as oto_product_slug, p.name as oto_product_name, p.price as oto_product_price, p.currency as oto_product_currency
  INTO oto_config
  FROM public.oto_offers o
  INNER JOIN public.products p ON p.id = o.oto_product_id AND p.is_active = true
  WHERE o.source_product_id = source_product_id_param
    AND o.is_active = true
  ORDER BY o.display_order ASC, o.created_at ASC
  LIMIT 1;

  -- No OTO configured
  IF oto_config IS NULL THEN
    RETURN jsonb_build_object('has_oto', false);
  END IF;

  -- CHECK: Does customer already own the OTO product?
  -- Check 1: user_product_access (logged-in users, by email via auth.users)
  IF EXISTS (
    SELECT 1
    FROM public.user_product_access upa
    INNER JOIN auth.users au ON au.id = upa.user_id
    WHERE au.email = customer_email_param
      AND upa.product_id = oto_config.oto_product_id
      AND (upa.access_expires_at IS NULL OR upa.access_expires_at > NOW())
  ) THEN
    RETURN jsonb_build_object(
      'has_oto', false,
      'reason', 'already_owns_oto_product',
      'skipped_oto_product_id', oto_config.oto_product_id,
      'skipped_oto_product_slug', oto_config.oto_product_slug
    );
  END IF;

  -- Check 2: guest_purchases (guest users, by email directly)
  IF EXISTS (
    SELECT 1
    FROM public.guest_purchases gp
    WHERE gp.customer_email = customer_email_param
      AND gp.product_id = oto_config.oto_product_id
  ) THEN
    RETURN jsonb_build_object(
      'has_oto', false,
      'reason', 'already_owns_oto_product',
      'skipped_oto_product_id', oto_config.oto_product_id,
      'skipped_oto_product_slug', oto_config.oto_product_slug
    );
  END IF;

  -- Generate unique coupon code (OTO-XXXXXXXX format)
  new_coupon_code := 'OTO-' || UPPER(SUBSTRING(REPLACE(gen_random_uuid()::TEXT, '-', ''), 1, 8));
  coupon_expires_at := NOW() + (oto_config.duration_minutes || ' minutes')::INTERVAL;

  -- Create the OTO coupon with race condition protection
  -- Use BEGIN/EXCEPTION to handle unique constraint violation
  BEGIN
    INSERT INTO public.coupons (
      code,
      name,
      discount_type,
      discount_value,
      currency,
      allowed_emails,
      allowed_product_ids,
      usage_limit_global,
      usage_limit_per_user,
      expires_at,
      is_active,
      is_oto_coupon,
      oto_offer_id,
      source_transaction_id
    ) VALUES (
      new_coupon_code,
      'OTO: ' || customer_email_param,
      oto_config.discount_type,
      oto_config.discount_value,
      CASE WHEN oto_config.discount_type = 'fixed' THEN oto_config.oto_product_currency ELSE NULL END,
      jsonb_build_array(customer_email_param),
      jsonb_build_array(oto_config.oto_product_id),
      1,  -- Can only be used once
      1,  -- By one person
      coupon_expires_at,
      true,
      true,
      oto_config.id,
      transaction_id_param
    )
    RETURNING id INTO new_coupon_id;
  EXCEPTION
    WHEN unique_violation THEN
      -- Race condition: another process already created the coupon
      -- Return the existing coupon instead
      SELECT c.id, c.code, c.discount_type, c.discount_value, c.expires_at,
             o.oto_product_id, p.slug as oto_product_slug, p.name as oto_product_name,
             p.price as oto_product_price, p.currency as oto_product_currency,
             o.duration_minutes
      INTO existing_coupon
      FROM public.coupons c
      INNER JOIN public.oto_offers o ON c.oto_offer_id = o.id
      INNER JOIN public.products p ON o.oto_product_id = p.id
      WHERE c.source_transaction_id = transaction_id_param
        AND c.is_oto_coupon = true
      LIMIT 1;

      IF existing_coupon IS NOT NULL THEN
        RETURN jsonb_build_object(
          'has_oto', true,
          'coupon_code', existing_coupon.code,
          'coupon_id', existing_coupon.id,
          'oto_product_id', existing_coupon.oto_product_id,
          'oto_product_slug', existing_coupon.oto_product_slug,
          'oto_product_name', existing_coupon.oto_product_name,
          'oto_product_price', existing_coupon.oto_product_price,
          'oto_product_currency', existing_coupon.oto_product_currency,
          'discount_type', existing_coupon.discount_type,
          'discount_value', existing_coupon.discount_value,
          'expires_at', existing_coupon.expires_at,
          'duration_minutes', existing_coupon.duration_minutes
        );
      END IF;
  END;

  -- Return OTO info for redirect
  RETURN jsonb_build_object(
    'has_oto', true,
    'coupon_code', new_coupon_code,
    'coupon_id', new_coupon_id,
    'oto_product_id', oto_config.oto_product_id,
    'oto_product_slug', oto_config.oto_product_slug,
    'oto_product_name', oto_config.oto_product_name,
    'oto_product_price', oto_config.oto_product_price,
    'oto_product_currency', oto_config.oto_product_currency,
    'discount_type', oto_config.discount_type,
    'discount_value', oto_config.discount_value,
    'expires_at', coupon_expires_at,
    'duration_minutes', oto_config.duration_minutes
  );
END;
$$;


ALTER FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") IS 'Generates a time-limited, email-bound coupon for OTO after purchase';



CREATE OR REPLACE FUNCTION "public"."get_admin_refund_requests"("status_filter" "text" DEFAULT NULL::"text", "limit_param" integer DEFAULT 50, "offset_param" integer DEFAULT 0) RETURNS TABLE("request_id" "uuid", "transaction_id" "uuid", "user_id" "uuid", "customer_email" "text", "product_id" "uuid", "product_name" "text", "reason" "text", "status" "text", "requested_amount" numeric, "currency" "text", "admin_id" "uuid", "admin_response" "text", "processed_at" timestamp with time zone, "created_at" timestamp with time zone, "purchase_date" timestamp with time zone, "stripe_payment_intent_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $$
BEGIN
    -- Check admin permission
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE admin_users.user_id = auth.uid()) THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        rr.id as request_id,
        rr.transaction_id,
        rr.user_id,
        rr.customer_email,
        rr.product_id,
        p.name as product_name,
        rr.reason,
        rr.status,
        rr.requested_amount,
        rr.currency,
        rr.admin_id,
        rr.admin_response,
        rr.processed_at,
        rr.created_at,
        pt.created_at as purchase_date,
        pt.stripe_payment_intent_id
    FROM public.refund_requests rr
    JOIN public.products p ON rr.product_id = p.id
    JOIN public.payment_transactions pt ON rr.transaction_id = pt.id
    WHERE (status_filter IS NULL OR rr.status = status_filter)
    ORDER BY
        CASE WHEN rr.status = 'pending' THEN 0 ELSE 1 END,
        rr.created_at DESC
    LIMIT limit_param
    OFFSET offset_param;
END;
$$;


ALTER FUNCTION "public"."get_admin_refund_requests"("status_filter" "text", "limit_param" integer, "offset_param" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cleanup_job_status"() RETURNS TABLE("jobname" "text", "schedule" "text", "command" "text", "active" boolean, "last_run" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cron.jobname,
        cron.schedule,
        cron.command,
        cron.active,
        cron.last_run_started_at as last_run
    FROM cron.job cron
    WHERE cron.jobname LIKE '%cleanup%'
    ORDER BY cron.jobname;
END;
$$;


ALTER FUNCTION "public"."get_cleanup_job_status"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_cleanup_job_status"() IS 'Get status of cleanup cron jobs for monitoring purposes';



CREATE OR REPLACE FUNCTION "public"."get_dashboard_stats"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
DECLARE
  total_users INTEGER;
  total_products INTEGER;
  total_revenue NUMERIC;
  active_users_7d INTEGER;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  SELECT COUNT(*) INTO total_users FROM auth.users;
  SELECT COUNT(*) INTO total_products FROM public.products WHERE is_active = true;
  SELECT COALESCE(SUM(amount), 0) INTO total_revenue
  FROM public.payment_transactions WHERE status = 'completed';

  SELECT COUNT(DISTINCT user_id) INTO active_users_7d
  FROM public.user_product_access
  WHERE created_at > NOW() - INTERVAL '7 days';

  RETURN jsonb_build_object(
    'totalProducts', total_products,
    'totalUsers', total_users,
    'totalAccess', (SELECT COUNT(*) FROM public.user_product_access),
    'activeUsers', active_users_7d,
    'totalRevenue', total_revenue
  );
END;
$$;


ALTER FUNCTION "public"."get_dashboard_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_detailed_revenue_stats"("p_product_id" "uuid" DEFAULT NULL::"uuid", "p_goal_start_date" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
DECLARE
  v_total_revenue_by_currency JSONB;
  v_today_revenue_by_currency JSONB;
  v_today_orders INTEGER;
  v_last_order_at TIMESTAMPTZ;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  SELECT COALESCE(jsonb_object_agg(currency, total), '{}'::jsonb)
  INTO v_total_revenue_by_currency
  FROM (
    SELECT pt.currency, SUM(pt.amount) as total
    FROM public.payment_transactions pt
    WHERE pt.status = 'completed'
      AND (p_product_id IS NULL OR pt.product_id = p_product_id)
      AND (p_goal_start_date IS NULL OR pt.created_at >= p_goal_start_date)
    GROUP BY pt.currency
  ) sub;

  SELECT
    COALESCE(jsonb_object_agg(currency, total), '{}'::jsonb),
    COALESCE(SUM(order_count), 0)::INTEGER
  INTO v_today_revenue_by_currency, v_today_orders
  FROM (
    SELECT pt.currency, SUM(pt.amount) as total, COUNT(*) as order_count
    FROM public.payment_transactions pt
    WHERE pt.status = 'completed'
      AND pt.created_at >= CURRENT_DATE
      AND (p_product_id IS NULL OR pt.product_id = p_product_id)
    GROUP BY pt.currency
  ) sub;

  SELECT pt.created_at INTO v_last_order_at
  FROM public.payment_transactions pt
  WHERE pt.status = 'completed'
    AND (p_product_id IS NULL OR pt.product_id = p_product_id)
  ORDER BY pt.created_at DESC
  LIMIT 1;

  RETURN jsonb_build_object(
    'totalRevenue', v_total_revenue_by_currency,
    'todayRevenue', v_today_revenue_by_currency,
    'todayOrders', v_today_orders,
    'lastOrderAt', v_last_order_at
  );
END;
$$;


ALTER FUNCTION "public"."get_detailed_revenue_stats"("p_product_id" "uuid", "p_goal_start_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_hourly_revenue_stats"("p_target_date" "date" DEFAULT CURRENT_DATE, "p_product_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("hour" integer, "amount_by_currency" "jsonb", "orders" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  WITH hours AS (
    SELECT generate_series(0, 23) AS h
  ),
  sales AS (
    SELECT
      EXTRACT(HOUR FROM pt.created_at)::INTEGER as sale_hour,
      pt.currency,
      SUM(pt.amount) as total_amount,
      COUNT(*) as total_orders
    FROM public.payment_transactions pt
    WHERE pt.status = 'completed'
      AND pt.created_at::DATE = p_target_date
      AND (p_product_id IS NULL OR pt.product_id = p_product_id)
    GROUP BY 1, 2
  ),
  aggregated_sales AS (
    SELECT
      sale_hour,
      jsonb_object_agg(currency, total_amount) as amount_by_currency,
      SUM(total_orders)::INTEGER as total_orders
    FROM sales
    GROUP BY sale_hour
  )
  SELECT
    hours.h,
    COALESCE(aggregated_sales.amount_by_currency, '{}'::jsonb),
    COALESCE(aggregated_sales.total_orders, 0)::INTEGER
  FROM hours
  LEFT JOIN aggregated_sales ON hours.h = aggregated_sales.sale_hour
  ORDER BY hours.h ASC;
END;
$$;


ALTER FUNCTION "public"."get_hourly_revenue_stats"("p_target_date" "date", "p_product_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  coupon_record RECORD;
  seconds_left INTEGER;
BEGIN
  -- Find valid OTO coupon for this email
  SELECT
    c.id,
    c.code,
    c.discount_type,
    c.discount_value,
    c.expires_at,
    o.duration_minutes,
    p.id as product_id,
    p.slug as product_slug,
    p.name as product_name,
    p.price as product_price,
    p.currency as product_currency
  INTO coupon_record
  FROM public.coupons c
  LEFT JOIN public.oto_offers o ON c.oto_offer_id = o.id
  LEFT JOIN public.products p ON o.oto_product_id = p.id
  WHERE c.code = coupon_code_param
    AND c.is_oto_coupon = true
    AND c.is_active = true
    AND c.expires_at > NOW()
    AND c.current_usage_count < COALESCE(c.usage_limit_global, 999999)
    AND c.allowed_emails ? email_param;

  IF coupon_record IS NULL THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Coupon not found or expired'
    );
  END IF;

  -- Calculate seconds remaining
  seconds_left := GREATEST(0, EXTRACT(EPOCH FROM (coupon_record.expires_at - NOW()))::INTEGER);

  RETURN jsonb_build_object(
    'valid', true,
    'coupon_id', coupon_record.id,
    'code', coupon_record.code,
    'discount_type', coupon_record.discount_type,
    'discount_value', coupon_record.discount_value,
    'expires_at', coupon_record.expires_at,
    'seconds_remaining', seconds_left,
    'duration_minutes', coupon_record.duration_minutes,
    'product', jsonb_build_object(
      'id', coupon_record.product_id,
      'slug', coupon_record.product_slug,
      'name', coupon_record.product_name,
      'price', coupon_record.product_price,
      'currency', coupon_record.product_currency
    )
  );
END;
$$;


ALTER FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") IS 'Returns OTO coupon details for frontend timer display';



CREATE OR REPLACE FUNCTION "public"."get_payment_statistics"("start_date" timestamp with time zone DEFAULT ("now"() - '30 days'::interval), "end_date" timestamp with time zone DEFAULT "now"()) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $_$
DECLARE
    stats JSONB;
BEGIN
    -- Security check: only admins can access payment statistics
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        RAISE EXCEPTION 'Unauthorized: Admin privileges required';
    END IF;
    
    -- Enhanced input validation for dates
    IF start_date IS NULL OR end_date IS NULL THEN
        RAISE EXCEPTION 'Start date and end date are required';
    END IF;
    
    IF start_date > end_date THEN
        RAISE EXCEPTION 'Start date must be before or equal to end date';
    END IF;
    
    -- Prevent future dates (data sanity check)
    IF start_date > NOW() OR end_date > NOW() + INTERVAL '1 day' THEN
        RAISE EXCEPTION 'Dates cannot be in the future';
    END IF;
    
    -- Prevent unreasonably old dates (prevent excessive processing)
    IF start_date < NOW() - INTERVAL '10 years' THEN
        RAISE EXCEPTION 'Start date cannot be more than 10 years in the past';
    END IF;
    
    -- Limit date range to prevent excessive data processing (max 1 year)
    IF end_date - start_date > INTERVAL '1 year' THEN
        RAISE EXCEPTION 'Date range too large (maximum 1 year)';
    END IF;
    
    -- Return sanitized statistics without exposing sensitive details
    SELECT jsonb_build_object(
        'period_start', start_date,
        'period_end', end_date,
        'total_transactions', COUNT(*),
        'total_revenue_range', CASE 
            WHEN COALESCE(SUM(amount), 0) = 0 THEN 'No revenue'
            WHEN COALESCE(SUM(amount), 0) < 100000 THEN 'Under $1,000'
            WHEN COALESCE(SUM(amount), 0) < 1000000 THEN '$1,000 - $10,000'
            ELSE 'Over $10,000'
        END,
        'transaction_status', jsonb_build_object(
            'completed', COUNT(*) FILTER (WHERE status = 'completed'),
            'refunded', COUNT(*) FILTER (WHERE status = 'refunded'),
            'disputed', COUNT(*) FILTER (WHERE status = 'disputed')
        ),
        'guest_purchase_summary', jsonb_build_object(
            'total_guest_purchases', (
                SELECT COUNT(*) 
                FROM public.guest_purchases 
                WHERE created_at BETWEEN start_date AND end_date
            ),
            'claimed_percentage', CASE 
                WHEN (SELECT COUNT(*) FROM public.guest_purchases WHERE created_at BETWEEN start_date AND end_date) = 0 
                THEN 0
                ELSE ROUND(
                    (SELECT COUNT(*) FROM public.guest_purchases WHERE claimed_at BETWEEN start_date AND end_date)::numeric * 100.0 /
                    (SELECT COUNT(*) FROM public.guest_purchases WHERE created_at BETWEEN start_date AND end_date), 1
                )
            END
        ),
        'generated_at', NOW()
    ) INTO stats
    FROM public.payment_transactions
    WHERE created_at BETWEEN start_date AND end_date;
    
    RETURN stats;
END;
$_$;


ALTER FUNCTION "public"."get_payment_statistics"("start_date" timestamp with time zone, "end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_product_order_bumps"("product_id_param" "uuid") RETURNS TABLE("bump_id" "uuid", "bump_product_id" "uuid", "bump_product_name" "text", "bump_product_description" "text", "bump_product_icon" "text", "bump_price" numeric, "original_price" numeric, "bump_access_duration" integer, "bump_currency" "text", "bump_title" "text", "bump_description" "text", "display_order" integer)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ob.id as bump_id,
    ob.bump_product_id,
    p.name as bump_product_name,
    p.description as bump_product_description,
    p.icon as bump_product_icon,
    COALESCE(ob.bump_price, p.price) as bump_price,
    p.price as original_price,
    COALESCE(ob.access_duration_days, p.auto_grant_duration_days) as bump_access_duration,
    p.currency as bump_currency,
    ob.bump_title,
    ob.bump_description,
    ob.display_order
  FROM public.order_bumps ob
  INNER JOIN public.products p ON p.id = ob.bump_product_id
  WHERE ob.main_product_id = product_id_param
    AND ob.is_active = true
    AND p.is_active = true
  ORDER BY ob.display_order ASC, ob.created_at ASC
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_product_order_bumps"("product_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_public_integrations_config"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  config_record RECORD;
  scripts_json JSONB;
BEGIN
  SELECT * INTO config_record FROM public.integrations_config WHERE id = 1;

  SELECT jsonb_agg(jsonb_build_object(
    'id', id, 'name', name, 'location', script_location,
    'content', script_content, 'category', category
  )) INTO scripts_json
  FROM public.custom_scripts WHERE is_active = true;

  RETURN jsonb_build_object(
    'gtm_container_id', config_record.gtm_container_id,
    'gtm_server_container_url', config_record.gtm_server_container_url,
    'facebook_pixel_id', config_record.facebook_pixel_id,
    'fb_capi_enabled', COALESCE(config_record.fb_capi_enabled, false),
    'send_conversions_without_consent', COALESCE(config_record.send_conversions_without_consent, false),
    'umami_website_id', config_record.umami_website_id,
    'umami_script_url', config_record.umami_script_url,
    'cookie_consent_enabled', config_record.cookie_consent_enabled,
    'consent_logging_enabled', config_record.consent_logging_enabled,
    'scripts', COALESCE(scripts_json, '[]'::jsonb)
  );
END;
$$;


ALTER FUNCTION "public"."get_public_integrations_config"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_revenue_goal"("p_product_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("goal_amount" bigint, "start_date" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT rg.goal_amount, rg.start_date
  FROM public.revenue_goals rg
  WHERE (p_product_id IS NULL AND rg.product_id IS NULL)
     OR (p_product_id IS NOT NULL AND rg.product_id = p_product_id);
END;
$$;


ALTER FUNCTION "public"."get_revenue_goal"("p_product_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_sales_chart_data"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_product_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("date" "text", "amount_by_currency" "jsonb", "orders" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  RETURN QUERY
  SELECT
    TO_CHAR(pt.created_at, 'YYYY-MM-DD') as date,
    COALESCE(jsonb_object_agg(pt.currency, currency_total), '{}'::jsonb) as amount_by_currency,
    SUM(currency_orders)::INTEGER as orders
  FROM (
    SELECT
      pt.created_at,
      pt.currency,
      SUM(pt.amount) as currency_total,
      COUNT(*) as currency_orders
    FROM public.payment_transactions pt
    WHERE pt.status = 'completed'
      AND pt.created_at >= p_start_date
      AND pt.created_at <= p_end_date
      AND (p_product_id IS NULL OR pt.product_id = p_product_id)
    GROUP BY TO_CHAR(pt.created_at, 'YYYY-MM-DD'), pt.currency, pt.created_at
  ) pt
  GROUP BY 1
  ORDER BY 1 ASC;
END;
$$;


ALTER FUNCTION "public"."get_sales_chart_data"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_product_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_payment_history"("user_id_param" "uuid") RETURNS TABLE("transaction_id" "uuid", "product_name" "text", "product_slug" "text", "amount" numeric, "currency" "text", "payment_date" timestamp with time zone, "status" "text", "refunded_amount" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '5s'
    AS $$
BEGIN
    -- Rate limiting: 30 calls per hour for payment history (SECURITY)
    IF NOT public.check_rate_limit('get_user_payment_history', 30, 3600) THEN
        RAISE EXCEPTION 'Rate limit exceeded. Please wait before requesting payment history again.';
    END IF;

    -- Input validation
    IF user_id_param IS NULL THEN
        RAISE EXCEPTION 'User ID is required';
    END IF;

    -- Security check: users can only view their own payment history (unless admin)
    IF user_id_param != auth.uid() THEN
        IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
            RAISE EXCEPTION 'Unauthorized: Can only view your own payment history';
        END IF;
    END IF;

    RETURN QUERY
    SELECT 
        pt.id,
        p.name,
        p.slug,
        pt.amount / 100.0, -- Convert cents to dollars for display
        pt.currency,
        pt.created_at,
        pt.status,
        pt.refunded_amount / 100.0 -- Convert cents to dollars for display
    FROM public.payment_transactions pt
    JOIN public.products p ON pt.product_id = p.id
    WHERE pt.user_id = user_id_param
    ORDER BY pt.created_at DESC
    LIMIT 100; -- Prevent excessive data retrieval
END;
$$;


ALTER FUNCTION "public"."get_user_payment_history"("user_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_profile"("user_id_param" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '5s'
    AS $$
DECLARE
    user_info JSONB;
    user_stats JSONB;
    user_access JSONB;
    current_user_id UUID;
BEGIN
    -- Input validation
    IF user_id_param IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Get current authenticated user
    current_user_id := auth.uid();
    IF current_user_id IS NULL THEN
        RAISE EXCEPTION 'Authentication required';
    END IF;
    
    -- Security check: only allow users to view their own profile or admins to view any profile
    IF user_id_param != current_user_id THEN
        IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = current_user_id) THEN
            RAISE EXCEPTION 'Unauthorized: Can only view your own profile';
        END IF;
    END IF;
    
    -- Get user info from auth.users
    SELECT jsonb_build_object(
        'id', id,
        'email', email,
        'created_at', created_at,
        'email_confirmed_at', email_confirmed_at,
        'last_sign_in_at', last_sign_in_at,
        'user_metadata', raw_user_meta_data
    ) INTO user_info
    FROM auth.users
    WHERE id = user_id_param;
    
    -- Return null if user not found
    IF user_info IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Get user statistics
    SELECT jsonb_build_object(
        'total_products', total_products,
        'total_value', total_value,
        'last_access_granted_at', last_access_granted_at,
        'first_access_granted_at', first_access_granted_at
    ) INTO user_stats
    FROM public.user_access_stats
    WHERE user_id = user_id_param;
    
    -- Get user access details
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', id,
            'product_id', product_id,
            'product_name', product_name,
            'product_slug', product_slug,
            'product_price', product_price,
            'product_currency', product_currency,
            'product_icon', product_icon,
            'product_is_active', product_is_active,
            'granted_at', access_created_at
        )
    ) INTO user_access
    FROM public.user_product_access_detailed
    WHERE user_id = user_id_param;
    
    -- Return the combined user profile
    RETURN jsonb_build_object(
        'user', user_info,
        'stats', user_stats,
        'access', COALESCE(user_access, '[]'::jsonb)
    );
END;
$$;


ALTER FUNCTION "public"."get_user_profile"("user_id_param" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_profile"("user_id_param" "uuid") IS 'Get complete user profile with access statistics. Users can only view their own profile, admins can view any profile.';



CREATE OR REPLACE FUNCTION "public"."get_user_purchases_with_refund_status"("user_id_param" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("transaction_id" "uuid", "product_id" "uuid", "product_name" "text", "product_slug" "text", "product_icon" "text", "amount" numeric, "currency" "text", "purchase_date" timestamp with time zone, "status" "text", "refunded_amount" numeric, "is_refundable" boolean, "refund_period_days" integer, "days_since_purchase" integer, "refund_eligible" boolean, "refund_request_status" "text", "refund_request_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $$
DECLARE
    target_user_id UUID;
BEGIN
    target_user_id := COALESCE(user_id_param, auth.uid());

    IF target_user_id IS NULL THEN
        RETURN;
    END IF;

    -- Only allow users to view their own purchases (or admins to view any)
    IF target_user_id != auth.uid() THEN
        IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE admin_users.user_id = auth.uid()) THEN
            RETURN;
        END IF;
    END IF;

    RETURN QUERY
    SELECT
        pt.id as transaction_id,
        p.id as product_id,
        p.name as product_name,
        p.slug as product_slug,
        p.icon as product_icon,
        pt.amount,
        pt.currency,
        pt.created_at as purchase_date,
        pt.status,
        pt.refunded_amount,
        p.is_refundable,
        p.refund_period_days,
        EXTRACT(DAY FROM NOW() - pt.created_at)::INTEGER as days_since_purchase,
        CASE
            WHEN pt.status = 'refunded' THEN false
            WHEN NOT p.is_refundable THEN false
            WHEN p.refund_period_days IS NOT NULL AND
                 EXTRACT(DAY FROM NOW() - pt.created_at) > p.refund_period_days THEN false
            ELSE true
        END as refund_eligible,
        rr.status as refund_request_status,
        rr.id as refund_request_id
    FROM public.payment_transactions pt
    JOIN public.products p ON pt.product_id = p.id
    LEFT JOIN public.refund_requests rr ON pt.id = rr.transaction_id AND rr.status IN ('pending', 'approved', 'rejected')
    WHERE pt.user_id = target_user_id
    ORDER BY pt.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_purchases_with_refund_status"("user_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_variant_group"("p_group_id" "uuid") RETURNS TABLE("id" "uuid", "name" "text", "slug" "text", "variant_name" character varying, "display_order" integer, "is_featured" boolean, "price" numeric, "currency" "text", "description" "text", "image_url" "text", "is_active" boolean)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT
    p.id,
    p.name,
    p.slug,
    pvg.variant_name,
    pvg.display_order,
    pvg.is_featured,
    p.price,
    p.currency,
    p.description,
    p.image_url,
    p.is_active
  FROM products p
  INNER JOIN product_variant_groups pvg ON pvg.product_id = p.id
  WHERE pvg.group_id = p_group_id
    AND p.is_active = true
  ORDER BY pvg.display_order ASC, p.price ASC;
$$;


ALTER FUNCTION "public"."get_variant_group"("p_group_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_variant_group"("p_group_id" "uuid") IS 'Get all active variants in a group by UUID (M:N schema)';



CREATE OR REPLACE FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") RETURNS TABLE("id" "uuid", "name" "text", "slug" "text", "variant_name" character varying, "display_order" integer, "is_featured" boolean, "price" numeric, "currency" "text", "description" "text", "image_url" "text", "is_active" boolean)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT
    p.id,
    p.name,
    p.slug,
    pvg.variant_name,
    pvg.display_order,
    pvg.is_featured,
    p.price,
    p.currency,
    p.description,
    p.image_url,
    p.is_active
  FROM products p
  INNER JOIN product_variant_groups pvg ON pvg.product_id = p.id
  INNER JOIN variant_groups vg ON vg.id = pvg.group_id
  WHERE vg.slug = p_slug
    AND p.is_active = true
  ORDER BY pvg.display_order ASC, p.price ASC;
$$;


ALTER FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") IS 'Get all active variants in a group by slug (M:N schema)';



CREATE OR REPLACE FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    product_record RECORD;
    current_user_id UUID;
    access_expires_at TIMESTAMPTZ;
    clean_slug TEXT;
BEGIN
    -- Input validation and sanitization
    IF product_slug_param IS NULL OR length(product_slug_param) = 0 OR length(product_slug_param) > 100 THEN
        RETURN FALSE;
    END IF;
    
    -- Validate access duration
    IF access_duration_days_param IS NOT NULL AND (access_duration_days_param < 0 OR access_duration_days_param > 3650) THEN
        RETURN FALSE; -- Max 10 years
    END IF;
    
    -- Sanitize slug
    clean_slug := regexp_replace(product_slug_param, '[^a-zA-Z0-9_-]', '', 'g');
    IF clean_slug IS NULL OR length(clean_slug) = 0 THEN
        RETURN FALSE;
    END IF;
    
    -- Get current authenticated user ID
    current_user_id := auth.uid();
    IF current_user_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Get product by slug (use sanitized slug)
    SELECT id, auto_grant_duration_days INTO product_record
    FROM public.products 
    WHERE slug = clean_slug AND is_active = true AND price = 0; -- Only allow free products
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Calculate access expiration
    IF access_duration_days_param IS NOT NULL THEN
        access_expires_at := NOW() + INTERVAL '1 day' * access_duration_days_param;
    ELSIF product_record.auto_grant_duration_days IS NOT NULL THEN
        access_expires_at := NOW() + INTERVAL '1 day' * product_record.auto_grant_duration_days;
    ELSE
        access_expires_at := NULL; -- Permanent access
    END IF;
    
    -- Insert or update user access
    INSERT INTO public.user_product_access (user_id, product_id, access_expires_at, access_duration_days)
    VALUES (current_user_id, product_record.id, access_expires_at, COALESCE(access_duration_days_param, product_record.auto_grant_duration_days))
    ON CONFLICT (user_id, product_id) 
    DO UPDATE SET 
        access_expires_at = EXCLUDED.access_expires_at,
        access_duration_days = EXCLUDED.access_duration_days,
        access_granted_at = NOW();
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer) IS 'Grant access to free products for authenticated users. Includes input validation and sanitization.';



CREATE OR REPLACE FUNCTION "public"."grant_product_access_service_role"("user_id_param" "uuid", "product_id_param" "uuid", "max_retries" integer DEFAULT 3) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $$
DECLARE
    product_auto_duration INTEGER;
    existing_record RECORD;
    new_expires_at TIMESTAMPTZ := NULL;
    final_duration INTEGER := NULL;
    retry_count INTEGER := 0;
    rows_affected INTEGER;
BEGIN
    -- Input validation
    IF user_id_param IS NULL OR product_id_param IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'User ID and Product ID are required'
        );
    END IF;
    
    -- Get product configuration
    SELECT auto_grant_duration_days 
    INTO product_auto_duration
    FROM public.products 
    WHERE id = product_id_param AND is_active = true;

    -- If product doesn't exist, return error
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Product not found or inactive'
        );
    END IF;

    -- Retry loop for optimistic locking
    WHILE retry_count < max_retries LOOP
        -- Get current state (including version for optimistic locking)
        SELECT 
            access_expires_at,
            version,
            (access_expires_at IS NULL) as has_permanent_access,
            (access_expires_at IS NOT NULL AND access_expires_at > NOW()) as has_active_access
        INTO existing_record
        FROM public.user_product_access
        WHERE user_id = user_id_param AND product_id = product_id_param;

        -- Calculate new expiration based on business logic
        IF FOUND THEN
            -- User has existing access record
            IF existing_record.has_permanent_access THEN
                -- User has PERMANENT access - NEVER downgrade
                new_expires_at := NULL;
                final_duration := NULL;
            ELSIF existing_record.has_active_access THEN
                -- User has active LIMITED access
                IF product_auto_duration IS NOT NULL THEN
                    -- Extend existing access
                    new_expires_at := existing_record.access_expires_at + (product_auto_duration || ' days')::INTERVAL;
                    final_duration := product_auto_duration;
                ELSE
                    -- Upgrade to permanent
                    new_expires_at := NULL;
                    final_duration := NULL;
                END IF;
            ELSE
                -- User's access expired - standard logic
                IF product_auto_duration IS NOT NULL THEN
                    new_expires_at := NOW() + (product_auto_duration || ' days')::INTERVAL;
                    final_duration := product_auto_duration;
                ELSE
                    new_expires_at := NULL;
                    final_duration := NULL;
                END IF;
            END IF;

            -- Optimistic update with version check
            UPDATE public.user_product_access 
            SET 
                access_granted_at = NOW(),
                access_duration_days = final_duration,
                access_expires_at = CASE
                    -- Never downgrade from permanent to limited
                    WHEN access_expires_at IS NULL THEN NULL
                    -- Otherwise use calculated value
                    ELSE new_expires_at
                END,
                version = version + 1
            WHERE 
                user_id = user_id_param 
                AND product_id = product_id_param 
                AND version = existing_record.version; -- Optimistic locking condition
            
            GET DIAGNOSTICS rows_affected = ROW_COUNT;
            
            IF rows_affected = 1 THEN
                -- Success! Update succeeded
                RETURN jsonb_build_object(
                    'success', true,
                    'operation', 'updated_existing',
                    'had_permanent_access', existing_record.has_permanent_access,
                    'had_active_access', existing_record.has_active_access,
                    'new_expires_at', new_expires_at,
                    'retry_count', retry_count
                );
            ELSE
                -- Optimistic lock failure - someone else modified the record
                retry_count := retry_count + 1;
                
                -- Small delay before retry (exponential backoff)
                IF retry_count < max_retries THEN
                    PERFORM pg_sleep(0.01 * (2 ^ retry_count)); -- 10ms, 20ms, 40ms
                END IF;
                
                CONTINUE; -- Retry the loop
            END IF;
        ELSE
            -- No existing record - create new with version = 1
            IF product_auto_duration IS NOT NULL THEN
                new_expires_at := NOW() + (product_auto_duration || ' days')::INTERVAL;
                final_duration := product_auto_duration;
            ELSE
                new_expires_at := NULL;
                final_duration := NULL;
            END IF;

            -- Insert new record with optimistic locking protection
            BEGIN
                INSERT INTO public.user_product_access (
                    user_id, 
                    product_id, 
                    access_duration_days, 
                    access_expires_at,
                    access_granted_at,
                    version
                )
                VALUES (
                    user_id_param, 
                    product_id_param, 
                    final_duration, 
                    new_expires_at,
                    NOW(),
                    1
                );
                
                -- Success! Insert succeeded
                RETURN jsonb_build_object(
                    'success', true,
                    'operation', 'created_new',
                    'new_expires_at', new_expires_at,
                    'retry_count', retry_count
                );
                
            EXCEPTION 
                WHEN unique_violation THEN
                    -- Someone else created the record concurrently
                    retry_count := retry_count + 1;
                    
                    -- Small delay before retry
                    IF retry_count < max_retries THEN
                        PERFORM pg_sleep(0.01 * (2 ^ retry_count));
                    END IF;
                    
                    CONTINUE; -- Retry the loop
            END;
        END IF;
    END LOOP;
    
    -- All retries exhausted - CRITICAL: Log this business failure
    BEGIN
        PERFORM public.log_admin_action(
            'critical_optimistic_lock_exhausted',
            'user_product_access',
            user_id_param::TEXT || '_' || product_id_param::TEXT,
            jsonb_build_object(
                'severity', 'CRITICAL',
                'error_type', 'optimistic_lock_retry_exhausted',
                'user_id', user_id_param,
                'product_id', product_id_param,
                'retry_count', retry_count,
                'max_retries', max_retries,
                'function_name', 'grant_product_access_service_role',
                'timestamp', extract(epoch from NOW()),
                'business_impact', 'Payment processed but product access not granted due to high concurrency',
                'context', 'optimistic_locking'
            )
        );
    EXCEPTION 
        WHEN OTHERS THEN
            -- If logging fails, continue anyway
            NULL;
    END;
    
    -- All retries exhausted
    RETURN jsonb_build_object(
        'success', false,
        'error', 'Concurrency conflict: Could not complete operation after retries',
        'retry_count', retry_count,
        'max_retries', max_retries,
        'retry_exceeded', true
    );
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error for debugging
        BEGIN
            PERFORM public.log_admin_action(
                'grant_access_error',
                'user_product_access',
                user_id_param::TEXT || '_' || product_id_param::TEXT,
                jsonb_build_object(
                    'severity', 'ERROR',
                    'error_type', 'database_exception',
                    'error_code', SQLSTATE,
                    'error_message', SQLERRM,
                    'user_id', user_id_param,
                    'product_id', product_id_param,
                    'retry_count', retry_count,
                    'function_name', 'grant_product_access_service_role',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'optimistic_locking'
                )
            );
        EXCEPTION 
            WHEN OTHERS THEN
                -- If logging fails, continue
                NULL;
        END;
        
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Database error occurred',
            'error_code', SQLSTATE,
            'retry_count', retry_count
        );
END;
$$;


ALTER FUNCTION "public"."grant_product_access_service_role"("user_id_param" "uuid", "product_id_param" "uuid", "max_retries" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_registration"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  claim_result JSON;
BEGIN
  PERFORM pg_advisory_xact_lock(hashtext('handle_new_user_registration'));

  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url')
  ON CONFLICT (id) DO NOTHING;

  INSERT INTO public.admin_users (user_id)
  SELECT NEW.id WHERE NOT EXISTS (SELECT 1 FROM public.admin_users LIMIT 1)
  ON CONFLICT (user_id) DO NOTHING;

  IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'claim_guest_purchases_for_user') THEN
    SELECT public.claim_guest_purchases_for_user(NEW.id) INTO claim_result;
  END IF;

  PERFORM public.log_audit_entry('auth.users', 'INSERT', NULL, jsonb_build_object('email', NEW.email), NEW.id);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_registration"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_rows_updated INTEGER;
BEGIN
  -- SECURITY: Atomic check-and-update in single statement to prevent race conditions
  -- This ensures sale validity is checked at the exact moment of update, not before
  UPDATE public.products
  SET sale_quantity_sold = COALESCE(sale_quantity_sold, 0) + 1
  WHERE id = p_product_id
    AND sale_price IS NOT NULL
    AND sale_price > 0
    AND (sale_price_until IS NULL OR sale_price_until > NOW())
    AND (sale_quantity_limit IS NULL OR COALESCE(sale_quantity_sold, 0) < sale_quantity_limit);

  GET DIAGNOSTICS v_rows_updated = ROW_COUNT;
  RETURN v_rows_updated > 0;
END;
$$;


ALTER FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") IS 'Atomically increment sale_quantity_sold for a product (uses row locking to prevent race conditions)';



CREATE OR REPLACE FUNCTION "public"."is_admin"("user_id_param" "uuid" DEFAULT NULL::"uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    current_user_id UUID;
    target_user_id UUID;
BEGIN
    -- Get current authenticated user (cache result)
    current_user_id := (SELECT auth.uid());
    
    -- Early return if no authenticated user
    IF current_user_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Use provided user_id or current authenticated user
    target_user_id := COALESCE(user_id_param, current_user_id);
    
    -- Security: Only allow users to check their own admin status
    -- Early return if trying to check another user's status
    IF user_id_param IS NOT NULL AND user_id_param != current_user_id THEN
        RETURN FALSE;
    END IF;
    
    -- Direct EXISTS check with index usage
    RETURN EXISTS (
        SELECT 1 FROM public.admin_users 
        WHERE user_id = target_user_id
    );
END;
$$;


ALTER FUNCTION "public"."is_admin"("user_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin_cached"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    current_user_id UUID;
    user_is_admin BOOLEAN;
    cache_key TEXT;
BEGIN
    -- Get current authenticated user
    current_user_id := (SELECT auth.uid());
    IF current_user_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Create session-specific cache key
    cache_key := 'app.user_is_admin_' || replace(current_user_id::TEXT, '-', '_');
    
    -- Try to get from session cache first
    BEGIN
        user_is_admin := current_setting(cache_key, true)::boolean;
        IF user_is_admin IS NOT NULL THEN
            RETURN user_is_admin;
        END IF;
    EXCEPTION 
        WHEN OTHERS THEN
            -- Cache miss, continue to DB lookup
            NULL;
    END;
    
    -- Check admin status from database
    SELECT EXISTS(
        SELECT 1 FROM public.admin_users 
        WHERE user_id = current_user_id
    ) INTO user_is_admin;
    
    -- Set session cache (expires with session)
    PERFORM set_config(cache_key, user_is_admin::TEXT, false);
    
    RETURN user_is_admin;
END;
$$;


ALTER FUNCTION "public"."is_admin_cached"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  -- No sale price set
  IF p_sale_price IS NULL OR p_sale_price <= 0 THEN
    RETURN FALSE;
  END IF;

  -- Check time limit (if set)
  IF p_sale_price_until IS NOT NULL AND p_sale_price_until <= NOW() THEN
    RETURN FALSE;
  END IF;

  -- Check quantity limit (if set)
  IF p_sale_quantity_limit IS NOT NULL AND COALESCE(p_sale_quantity_sold, 0) >= p_sale_quantity_limit THEN
    RETURN FALSE;
  END IF;

  RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) IS 'Check if sale price is currently active (considers both time and quantity limits)';



CREATE OR REPLACE FUNCTION "public"."log_admin_action"("action_name" "text", "target_type" "text", "target_id" "text", "action_details" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
BEGIN
    -- SECURITY: Rate limiting to prevent log spam attacks by authenticated users
    -- Admins get higher limits since they need to perform legitimate admin actions
    IF EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        -- Admin users: 200 log entries per hour (higher limit for legitimate admin work)
        IF NOT public.check_rate_limit('log_admin_action_admin', 200, 3600) THEN
            RAISE EXCEPTION 'Rate limit exceeded: Too many admin actions logged. Please wait before performing more actions.';
        END IF;
    ELSE
        -- Non-admin authenticated users: 20 log entries per hour (much stricter)
        IF NOT public.check_rate_limit('log_admin_action_user', 20, 3600) THEN
            RAISE EXCEPTION 'Rate limit exceeded: Too many log entries. Please wait before performing more actions.';
        END IF;
    END IF;

    -- Input validation
    IF action_name IS NULL OR length(action_name) = 0 OR length(action_name) > 100 THEN
        RAISE EXCEPTION 'Invalid action name: must be 1-100 characters';
    END IF;
    
    IF target_type IS NULL OR length(target_type) = 0 OR length(target_type) > 50 THEN
        RAISE EXCEPTION 'Invalid target type: must be 1-50 characters';
    END IF;
    
    IF target_id IS NULL OR length(target_id) = 0 OR length(target_id) > 255 THEN
        RAISE EXCEPTION 'Invalid target ID: must be 1-255 characters';
    END IF;
    
    -- Validate JSONB is not too large (prevent DoS) - reduced limit for non-admins
    IF EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        -- Admins can log larger details (64KB) for legitimate debugging
        IF pg_column_size(action_details) > 65536 THEN -- 64KB limit
            RAISE EXCEPTION 'Action details too large (max 64KB for admins)';
        END IF;
    ELSE
        -- Non-admin users get much smaller limit (8KB) to prevent abuse
        IF pg_column_size(action_details) > 8192 THEN -- 8KB limit
            RAISE EXCEPTION 'Action details too large (max 8KB for non-admin users)';
        END IF;
    END IF;
    
    -- Insert admin action with proper user identification
    INSERT INTO public.admin_actions (admin_id, action, target_type, target_id, details)
    VALUES (
        auth.uid(), -- NULL for system operations when no user is logged in
        action_name,
        target_type,
        target_id,
        action_details
    );
END;
$$;


ALTER FUNCTION "public"."log_admin_action"("action_name" "text", "target_type" "text", "target_id" "text", "action_details" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_admin_action_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
    action_name TEXT;
    action_details JSONB;
BEGIN
    -- Only log if the user is an admin
    IF EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
        -- Determine specific action name based on operation and changes
        IF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'payment_transactions' THEN
            IF OLD.status != NEW.status AND NEW.status = 'refunded' THEN
                action_name := 'payment_refunded';
                -- Standardized logging format
                action_details := jsonb_build_object(
                    'severity', 'INFO',
                    'action_type', 'payment_status_change',
                    'transaction_id', NEW.id,
                    'old_status', OLD.status,
                    'new_status', NEW.status,
                    'refunded_amount', NEW.refunded_amount,
                    'refund_reason', NEW.refund_reason,
                    'refunded_at', NEW.refunded_at,
                    'refunded_by', auth.uid(),
                    'customer_email_hash', encode(digest(NEW.customer_email, 'sha256'), 'hex'),
                    'function_name', 'log_admin_action_trigger',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'payment_refund_processing'
                );
            ELSE
                action_name := 'payment_updated';
                -- Standardized logging format
                action_details := jsonb_build_object(
                    'severity', 'INFO',
                    'action_type', 'payment_modification',
                    'transaction_id', NEW.id,
                    'changed_fields', jsonb_build_object(
                        'status', CASE WHEN OLD.status != NEW.status THEN jsonb_build_object('old', OLD.status, 'new', NEW.status) END,
                        'refunded_amount', CASE WHEN OLD.refunded_amount != NEW.refunded_amount THEN jsonb_build_object('old', OLD.refunded_amount, 'new', NEW.refunded_amount) END,
                        'updated_at', NEW.updated_at
                    ),
                    'function_name', 'log_admin_action_trigger',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'payment_update_processing'
                );
            END IF;
        ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'guest_purchases' THEN
            action_name := 'guest_purchase_claimed';
            -- Standardized logging format
            action_details := jsonb_build_object(
                'severity', 'INFO',
                'action_type', 'guest_purchase_claim',
                'purchase_id', NEW.id,
                'claimed_by', NEW.claimed_by_user_id,
                'claimed_at', NEW.claimed_at,
                'customer_email_hash', encode(digest(NEW.customer_email, 'sha256'), 'hex'),
                'product_id', NEW.product_id,
                'function_name', 'log_admin_action_trigger',
                'timestamp', extract(epoch from NOW()),
                'context', 'guest_claim_processing'
            );
        ELSE
            action_name := TG_OP::TEXT;
            -- Standardized logging format for generic operations
            action_details := CASE 
                WHEN TG_OP = 'INSERT' THEN jsonb_build_object(
                    'severity', 'INFO',
                    'action_type', 'record_creation',
                    'record_id', NEW.id,
                    'table', TG_TABLE_NAME,
                    'operation', 'INSERT',
                    'function_name', 'log_admin_action_trigger',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'database_operation'
                )
                WHEN TG_OP = 'DELETE' THEN jsonb_build_object(
                    'severity', 'INFO',
                    'action_type', 'record_deletion',
                    'record_id', OLD.id,
                    'table', TG_TABLE_NAME,
                    'operation', 'DELETE',
                    'function_name', 'log_admin_action_trigger',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'database_operation'
                )
                ELSE jsonb_build_object(
                    'severity', 'WARNING',
                    'action_type', 'unknown_operation',
                    'operation', 'UNKNOWN',
                    'function_name', 'log_admin_action_trigger',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'database_operation'
                )
            END;
        END IF;
        
        -- Use the main log_admin_action function
        PERFORM public.log_admin_action(
            action_name,
            TG_TABLE_NAME::TEXT,
            COALESCE(NEW.id::TEXT, OLD.id::TEXT),
            action_details
        );
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."log_admin_action_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_audit_entry"("table_name_param" "text", "operation_param" "text", "old_values_param" "jsonb" DEFAULT NULL::"jsonb", "new_values_param" "jsonb" DEFAULT NULL::"jsonb", "user_id_param" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
BEGIN
    -- Input validation
    IF table_name_param IS NULL OR length(table_name_param) = 0 OR length(table_name_param) > 100 THEN
        RAISE EXCEPTION 'Invalid table name: must be 1-100 characters';
    END IF;
    
    IF operation_param IS NULL OR operation_param NOT IN ('INSERT', 'UPDATE', 'DELETE') THEN
        RAISE EXCEPTION 'Invalid operation: must be INSERT, UPDATE, or DELETE';
    END IF;
    
    -- Validate JSONB size (prevent DoS)
    IF pg_column_size(old_values_param) > 65536 THEN -- 64KB limit
        RAISE EXCEPTION 'Old values too large (max 64KB)';
    END IF;
    
    IF pg_column_size(new_values_param) > 65536 THEN -- 64KB limit
        RAISE EXCEPTION 'New values too large (max 64KB)';
    END IF;
    
    -- Insert audit entry
    INSERT INTO public.audit_log (
        table_name, 
        operation, 
        old_values, 
        new_values, 
        user_id,
        performed_at
    ) VALUES (
        table_name_param,
        operation_param,
        old_values_param,
        new_values_param,
        COALESCE(user_id_param, auth.uid()),
        NOW()
    );
END;
$$;


ALTER FUNCTION "public"."log_audit_entry"("table_name_param" "text", "operation_param" "text", "old_values_param" "jsonb", "new_values_param" "jsonb", "user_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_product_price_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only log if price or sale_price actually changed
  IF (TG_OP = 'UPDATE' AND
      (OLD.price != NEW.price OR
       OLD.sale_price IS DISTINCT FROM NEW.sale_price OR
       OLD.currency != NEW.currency OR
       OLD.vat_rate != NEW.vat_rate)) OR
     TG_OP = 'INSERT' THEN

    -- Close previous price period
    IF TG_OP = 'UPDATE' THEN
      UPDATE product_price_history
      SET effective_until = NOW()
      WHERE product_id = OLD.id
        AND effective_until IS NULL;
    END IF;

    -- Insert new price record
    INSERT INTO product_price_history (
      product_id, price, sale_price, currency, vat_rate,
      price_includes_vat, effective_from
    ) VALUES (
      NEW.id, NEW.price, NEW.sale_price, NEW.currency, NEW.vat_rate,
      NEW.price_includes_vat, NOW()
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_product_price_change"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_product_price_change"() IS 'Automatically logs price changes to product_price_history for Omnibus compliance';



CREATE OR REPLACE FUNCTION "public"."logs_monitoring_check"("new_action_details" "jsonb" DEFAULT NULL::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    warning_count INTEGER;
    last_email_sent TIMESTAMPTZ;
BEGIN
    -- If this is a CRITICAL event passed from trigger - send immediate email!
    IF new_action_details IS NOT NULL AND (new_action_details->>'severity') = 'CRITICAL' THEN
        -- Send immediate email for every critical event
        BEGIN
            PERFORM public.send_monitoring_email(
                'critical_event_immediate',
                jsonb_build_object(
                    'severity', 'CRITICAL',
                    'event_type', 'immediate_critical_alert',
                    'action_details', new_action_details,
                    'timestamp', extract(epoch from NOW()),
                    'message', 'CRITICAL: Immediate attention required',
                    'action_required', 'Please investigate immediately',
                    'dashboard_link', '/admin/monitoring',
                    'urgent', true
                )
            );
        EXCEPTION 
            WHEN OTHERS THEN
                NULL; -- Never break the main operation
        END;
    END IF;
    
    -- For WARNING events OR regular monitoring check - handle batch warnings
    IF new_action_details IS NULL OR (new_action_details->>'severity') = 'WARNING' THEN
        -- Count warnings in last 5 minutes (for batch alerts)
        SELECT COUNT(*) INTO warning_count
        FROM public.admin_actions
        WHERE (details->>'severity') = 'WARNING'
          AND (details->>'context') LIKE '%payment%'
          AND created_at > NOW() - INTERVAL '5 minutes';
        
        -- Check when we last sent payment alert email
        SELECT MAX(created_at) INTO last_email_sent
        FROM public.admin_actions
        WHERE action = 'monitoring_email_sent'
          AND (details->>'alert_type') = 'payment_issues';
        
        -- If too many payment warnings AND we haven't sent email recently
        IF warning_count >= 5 AND 
           (last_email_sent IS NULL OR last_email_sent < NOW() - INTERVAL '15 minutes') THEN
            
            -- Send email about payment issues
            PERFORM public.send_monitoring_email(
                'payment_issues',
                jsonb_build_object(
                    'warning_count', warning_count,
                    'time_window', '5 minutes',
                    'severity', 'MEDIUM',
                    'message', 'Payment system has ' || warning_count || ' warnings in last 5 minutes',
                    'action_required', 'Please review payment processing',
                    'dashboard_link', '/admin/payments'
                )
            );
            
            -- Log that we sent email (just once)
            PERFORM public.log_admin_action(
                'monitoring_email_sent',
                'admin_actions',
                'email_notification', 
                jsonb_build_object(
                    'severity', 'INFO',
                    'alert_type', 'payment_issues',
                    'warning_count', warning_count,
                    'email_sent_at', extract(epoch from NOW()),
                    'function_name', 'logs_monitoring_check',
                    'context', 'email_notification'
                )
            );
        END IF;
    END IF;
    
EXCEPTION 
    WHEN OTHERS THEN
        -- Don't break anything if monitoring fails
        NULL;
END;
$$;


ALTER FUNCTION "public"."logs_monitoring_check"("new_action_details" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."logs_monitoring_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
    -- Call unified monitoring function for any CRITICAL or WARNING event
    IF TG_TABLE_NAME = 'admin_actions' AND 
       (NEW.details->>'severity') IN ('CRITICAL', 'WARNING') THEN
        
        -- Pass the event details to the monitoring function
        BEGIN
            PERFORM public.logs_monitoring_check(NEW.details);
        EXCEPTION 
            WHEN OTHERS THEN
                NULL; -- Never break the main operation
        END;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."logs_monitoring_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_refund_request"("request_id_param" "uuid", "action_param" "text", "admin_response_param" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '10s'
    AS $$
DECLARE
    current_admin_id UUID;
    request_record RECORD;
BEGIN
    current_admin_id := auth.uid();

    -- Check admin permission
    IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = current_admin_id) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin privileges required');
    END IF;

    IF action_param NOT IN ('approve', 'reject') THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid action. Must be "approve" or "reject"');
    END IF;

    -- Get request details
    SELECT rr.*, pt.stripe_payment_intent_id, p.name as product_name
    INTO request_record
    FROM public.refund_requests rr
    JOIN public.payment_transactions pt ON rr.transaction_id = pt.id
    JOIN public.products p ON rr.product_id = p.id
    WHERE rr.id = request_id_param;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Refund request not found');
    END IF;

    IF request_record.status != 'pending' THEN
        RETURN jsonb_build_object('success', false, 'error', 'Request already processed', 'current_status', request_record.status);
    END IF;

    -- Update request status
    UPDATE public.refund_requests
    SET
        status = CASE WHEN action_param = 'approve' THEN 'approved' ELSE 'rejected' END,
        admin_id = current_admin_id,
        admin_response = admin_response_param,
        processed_at = NOW(),
        updated_at = NOW()
    WHERE id = request_id_param;

    IF action_param = 'approve' THEN
        RETURN jsonb_build_object(
            'success', true,
            'status', 'approved',
            'message', 'Refund request approved. Process refund via Stripe.',
            'transaction_id', request_record.transaction_id,
            'stripe_payment_intent_id', request_record.stripe_payment_intent_id,
            'amount', request_record.requested_amount,
            'currency', request_record.currency
        );
    ELSE
        RETURN jsonb_build_object(
            'success', true,
            'status', 'rejected',
            'message', 'Refund request rejected',
            'admin_response', admin_response_param
        );
    END IF;
END;
$$;


ALTER FUNCTION "public"."process_refund_request"("request_id_param" "uuid", "action_param" "text", "admin_response_param" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_stripe_payment_completion"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text" DEFAULT NULL::"text", "user_id_param" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '15s'
    AS $_$
DECLARE
    current_user_id UUID;
    product_record RECORD;
    existing_user_id UUID;
    access_expires_at TIMESTAMPTZ := NULL;
    scenario TEXT;
    result JSONB;
BEGIN
    -- TEMPORARY DEBUG: Log function entry with all parameters
    BEGIN
        PERFORM public.log_admin_action(
            'payment_processing_debug_start',
            'payment_transactions',
            session_id_param,
            jsonb_build_object(
                'severity', 'DEBUG',
                'session_id', session_id_param,
                'product_id', product_id_param,
                'customer_email', customer_email_param,
                'amount', amount_total,
                'currency', currency_param,
                'stripe_payment_intent_id', stripe_payment_intent_id,
                'user_id_param', user_id_param,
                'function_name', 'process_stripe_payment_completion',
                'timestamp', extract(epoch from NOW()),
                'context', 'debug_function_entry'
            )
        );
    EXCEPTION
        WHEN OTHERS THEN
            -- If logging fails, continue anyway
            NULL;
    END;

    -- Rate limiting: 100 calls per hour for payment processing (increased for checkout)
    IF NOT public.check_rate_limit('process_stripe_payment_completion', 100, 3600) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Rate limit exceeded. Please wait before processing another payment.');
    END IF;

    -- Enhanced input validation (SECURITY)
    IF session_id_param IS NULL OR length(session_id_param) = 0 OR length(session_id_param) > 255 THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid session ID');
    END IF;
    
    -- Validate session_id format (Stripe sessions start with 'cs_' or Payment Intents with 'pi_')
    IF NOT (session_id_param ~* '^(cs_|pi_)[a-zA-Z0-9_]+$') THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid session ID format');
    END IF;
    
    IF product_id_param IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Product ID is required');
    END IF;
    
    -- Enhanced email validation using dedicated function
    IF NOT public.validate_email_format(customer_email_param) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Valid email address is required');
    END IF;
    
    IF amount_total IS NULL OR amount_total <= 0 OR amount_total > 99999999 THEN -- Max $999,999.99
        RETURN jsonb_build_object('success', false, 'error', 'Invalid amount');
    END IF;
    
    -- Enhanced currency validation with ISO 4217 code checking
    IF currency_param IS NULL OR 
       length(currency_param) != 3 OR
       NOT (upper(currency_param) ~ '^[A-Z]{3}$') OR
       NOT (upper(currency_param) IN ('USD', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY', 'CHF', 'CNY', 'SEK', 'NOK', 'DKK', 'PLN', 'CZK', 'HUF', 'RON', 'BGN', 'HRK', 'RUB', 'TRY', 'BRL', 'MXN', 'INR', 'KRW', 'SGD', 'HKD', 'NZD', 'ZAR', 'ILS', 'THB', 'MYR', 'PHP', 'IDR', 'VND')) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid or unsupported currency code');
    END IF;
    
    -- Validate Stripe Payment Intent ID format if provided
    IF stripe_payment_intent_id IS NOT NULL AND (
       length(stripe_payment_intent_id) = 0 OR 
       length(stripe_payment_intent_id) > 255 OR
       NOT (stripe_payment_intent_id ~* '^pi_[a-zA-Z0-9_]+$')
    ) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid Stripe Payment Intent ID format');
    END IF;

    -- Authorization check: Verify caller has permission to process payments for the specified user (SECURITY)
    IF user_id_param IS NOT NULL THEN
        -- If user_id is specified, verify authorization
        IF (select auth.role()) = 'service_role' THEN
            -- Service role can process payments for any user (trusted backend)
            current_user_id := user_id_param;
        ELSIF auth.uid() = user_id_param THEN
            -- Authenticated user can only process payments for themselves
            current_user_id := user_id_param;
        ELSE
            -- Unauthorized: user trying to process payment for different user
            RETURN jsonb_build_object('success', false, 'error', 'Unauthorized: Cannot process payment for another user');
        END IF;
    ELSE
        -- No user_id specified - this is a guest purchase
        current_user_id := NULL;
    END IF;

    -- Enhanced idempotency check: Check both session_id AND stripe_payment_intent_id
    -- This prevents duplicate processing if Stripe sends webhooks multiple times
    SELECT 
        p.id, p.name, p.slug, p.auto_grant_duration_days, p.price, p.currency as product_currency,
        EXISTS(
            SELECT 1 FROM public.payment_transactions pt 
            WHERE pt.session_id = session_id_param 
               OR (process_stripe_payment_completion.stripe_payment_intent_id IS NOT NULL AND pt.stripe_payment_intent_id = process_stripe_payment_completion.stripe_payment_intent_id)
        ) as transaction_exists
    INTO product_record
    FROM public.products p
    WHERE p.id = product_id_param AND p.is_active = true;

    -- Check if product exists
    IF product_record.id IS NULL THEN
        -- TEMPORARY DEBUG: Log product not found
        BEGIN
            PERFORM public.log_admin_action(
                'payment_processing_debug_product_not_found',
                'products',
                product_id_param::TEXT,
                jsonb_build_object(
                    'severity', 'DEBUG',
                    'product_id', product_id_param,
                    'session_id', session_id_param,
                    'context', 'debug_product_lookup_failed'
                )
            );
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;
        
        RETURN jsonb_build_object('success', false, 'error', 'Product not found or inactive');
    END IF;

    -- TEMPORARY DEBUG: Log product found and transaction status
    BEGIN
        PERFORM public.log_admin_action(
            'payment_processing_debug_product_found',
            'products',
            product_record.id::TEXT,
            jsonb_build_object(
                'severity', 'DEBUG',
                'product_id', product_record.id,
                'product_name', product_record.name,
                'transaction_exists', product_record.transaction_exists,
                'session_id', session_id_param,
                'context', 'debug_product_lookup_success'
            )
        );
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;

    -- Calculate access expiry once (for response)
    IF product_record.auto_grant_duration_days IS NOT NULL THEN
        access_expires_at := NOW() + (product_record.auto_grant_duration_days || ' days')::INTERVAL;
    END IF;

    -- EARLY RETURN: Check for idempotency first (much cleaner than nested IF/ELSE)
    IF product_record.transaction_exists THEN
        -- Transaction already exists - return idempotent success
        scenario := 'idempotent_transaction';
        
        -- TEMPORARY DEBUG: Log idempotent processing
        BEGIN
            PERFORM public.log_admin_action(
                'payment_processing_debug_idempotent',
                'payment_transactions',
                session_id_param,
                jsonb_build_object(
                    'severity', 'DEBUG',
                    'session_id', session_id_param,
                    'product_id', product_id_param,
                    'customer_email', customer_email_param,
                    'scenario', scenario,
                    'context', 'debug_idempotent_webhook_detected'
                )
            );
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;
        
        RETURN jsonb_build_object(
            'success', true,
            'access_granted', true,
            'already_had_access', true, -- This is true because we found an existing transaction
            'scenario', scenario,
            'access_expires_at', access_expires_at,
            'requires_login', false,
            'send_magic_link', false,
            'customer_email', customer_email_param,
            'grant_details', 'Payment already processed successfully'
        );
    END IF;

    -- NEW TRANSACTION: Process payment and grant access
    INSERT INTO public.payment_transactions (
        session_id, user_id, product_id, customer_email, amount, currency, 
        stripe_payment_intent_id, status, metadata
    ) VALUES (
        session_id_param, current_user_id, product_id_param, customer_email_param, amount_total, currency_param,
        process_stripe_payment_completion.stripe_payment_intent_id, 'completed',
        jsonb_build_object(
            'stripe_session_id', session_id_param,
            'product_slug', product_record.slug,
            'amount_display', (amount_total / 100.0)::text || ' ' || upper(currency_param),
            'idempotency_check', 'webhook_processed',
            'processed_at', NOW()
        )
    ) ON CONFLICT (session_id) DO NOTHING;

    -- SCENARIO 1: User is logged in
    IF current_user_id IS NOT NULL THEN
        scenario := 'logged_in_user';
        
        -- Use optimistic locking function with enhanced error handling
        BEGIN
            SELECT public.grant_product_access_service_role(current_user_id, product_id_param) INTO result;
            IF (result->>'success')::boolean = false THEN
                -- Handle specific optimistic locking failures
                IF (result->>'retry_exceeded')::boolean = true THEN
                    -- High concurrency - this is actually quite rare and indicates very high traffic
                    PERFORM public.log_admin_action(
                        'high_concurrency_detected',
                        'user_product_access',
                        current_user_id::TEXT || '_' || product_id_param::TEXT,
                        jsonb_build_object(
                            'severity', 'WARNING',
                            'error_type', 'optimistic_lock_retry_exceeded',
                            'user_id', current_user_id,
                            'product_id', product_id_param,
                            'session_id', session_id_param,
                            'retry_count', result->>'retry_count',
                            'function_name', 'process_stripe_payment_completion',
                            'timestamp', extract(epoch from NOW()),
                            'customer_email', customer_email_param,
                            'context', 'payment_processing'
                        )
                    );
                    
                    RETURN jsonb_build_object(
                        'success', false,
                        'error', 'High concurrency detected. Please try again.',
                        'error_type', 'concurrency_conflict',
                        'retry_safe', true,
                        'customer_email', customer_email_param
                    );
                ELSE
                    -- Other error from optimistic locking function
                    RETURN jsonb_build_object(
                        'success', false,
                        'error', 'Failed to grant access: ' || COALESCE(result->>'error', 'Unknown error'),
                        'error_details', result,
                        'customer_email', customer_email_param
                    );
                END IF;
            END IF;
        EXCEPTION 
            WHEN OTHERS THEN
                -- Critical error: payment processed but access grant failed
                PERFORM public.log_admin_action(
                    'critical_access_grant_failure',
                    'user_product_access',
                    current_user_id::TEXT || '_' || product_id_param::TEXT,
                    jsonb_build_object(
                        'severity', 'CRITICAL',
                        'error_type', 'access_grant_exception',
                        'error_code', SQLSTATE,
                        'error_message', SQLERRM,
                        'user_id', current_user_id,
                        'product_id', product_id_param,
                        'session_id', session_id_param,
                        'payment_amount', amount_total,
                        'customer_email', customer_email_param,
                        'function_name', 'process_stripe_payment_completion',
                        'timestamp', extract(epoch from NOW()),
                        'context', 'payment_processing'
                    )
                );
                
                RETURN jsonb_build_object(
                    'success', false, 
                    'error', 'Payment processed but access grant failed. Support has been notified.',
                    'error_reference', extract(epoch from NOW())::bigint,
                    'requires_manual_intervention', true,
                    'customer_email', customer_email_param
                );
        END;

        RETURN jsonb_build_object(
            'success', true,
            'access_granted', true,
            'already_had_access', false, -- Optimistic function provides this info in result
            'scenario', scenario,
            'access_expires_at', access_expires_at,
            'requires_login', false,
            'send_magic_link', false,
            'customer_email', customer_email_param,
            'grant_details', result -- Include optimistic locking details
        );
    END IF;

    -- SCENARIO 2 & 3: No current user - single query to check if email exists
    SELECT id INTO existing_user_id FROM auth.users WHERE email = customer_email_param;

    IF existing_user_id IS NOT NULL THEN
        -- SCENARIO 2: Email exists - grant access to that user using optimistic locking
        scenario := 'existing_user_email';
        
        BEGIN
            SELECT public.grant_product_access_service_role(existing_user_id, product_id_param) INTO result;

            IF (result->>'success')::boolean = false THEN
                -- Handle specific optimistic locking failures
                IF (result->>'retry_exceeded')::boolean = true THEN
                    PERFORM public.log_admin_action(
                        'high_concurrency_detected',
                        'user_product_access',
                        existing_user_id::TEXT || '_' || product_id_param::TEXT,
                        jsonb_build_object(
                            'severity', 'WARNING',
                            'error_type', 'optimistic_lock_retry_exceeded',
                            'user_id', existing_user_id,
                            'product_id', product_id_param,
                            'session_id', session_id_param,
                            'retry_count', result->>'retry_count',
                            'customer_email', customer_email_param,
                            'function_name', 'process_stripe_payment_completion',
                            'timestamp', extract(epoch from NOW()),
                            'context', 'payment_processing_existing_user'
                        )
                    );
                    
                    RETURN jsonb_build_object(
                        'success', false,
                        'error', 'High concurrency detected. Please try again.',
                        'error_type', 'concurrency_conflict',
                        'retry_safe', true,
                        'customer_email', customer_email_param
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'success', false,
                        'error', 'Failed to grant access: ' || COALESCE(result->>'error', 'Unknown error'),
                        'error_details', result,
                        'customer_email', customer_email_param
                    );
                END IF;
            END IF;
        EXCEPTION 
            WHEN OTHERS THEN
                -- Critical error: payment processed but access grant failed
                PERFORM public.log_admin_action(
                    'critical_access_grant_failure',
                    'user_product_access',
                    existing_user_id::TEXT || '_' || product_id_param::TEXT,
                    jsonb_build_object(
                        'severity', 'CRITICAL',
                        'error_type', 'access_grant_exception',
                        'error_code', SQLSTATE,
                        'error_message', SQLERRM,
                        'user_id', existing_user_id,
                        'product_id', product_id_param,
                        'session_id', session_id_param,
                        'payment_amount', amount_total,
                        'customer_email', customer_email_param,
                        'function_name', 'process_stripe_payment_completion',
                        'timestamp', extract(epoch from NOW()),
                        'context', 'payment_processing_existing_user'
                    )
                );
                
                RETURN jsonb_build_object(
                    'success', false, 
                    'error', 'Payment processed but access grant failed. Support has been notified.',
                    'error_reference', extract(epoch from NOW())::bigint,
                    'requires_manual_intervention', true,
                    'customer_email', customer_email_param
                );
        END;

        result := jsonb_build_object(
            'success', true,
            'access_granted', true,
            'already_had_access', false,
            'scenario', scenario,
            'access_expires_at', access_expires_at,
            'requires_login', true,
            'send_magic_link', true,
            'customer_email', customer_email_param,
            'grant_details', result
        );
    ELSE
        -- SCENARIO 3: Email not in database - save as guest purchase with proper idempotency
        scenario := 'guest_purchase';
        
        -- Enhanced idempotency: Use INSERT with proper conflict handling
        BEGIN
            INSERT INTO public.guest_purchases (customer_email, product_id, session_id, transaction_amount)
            VALUES (customer_email_param, product_id_param, session_id_param, amount_total);
        EXCEPTION 
            WHEN unique_violation THEN
                -- Idempotency: Guest purchase already exists for this session
                -- This is expected behavior for duplicate webhooks - continue processing normally
                NULL; -- Do nothing, guest purchase already recorded
        END;

        result := jsonb_build_object(
            'success', true,
            'access_granted', false,
            'already_had_access', false,
            'scenario', scenario,
            'access_expires_at', access_expires_at,
            'requires_login', true,
            'send_magic_link', true,
            'is_guest_purchase', true,
            'customer_email', customer_email_param
        );
    END IF;

    RETURN result;

EXCEPTION
    WHEN serialization_failure THEN
        -- SERIALIZABLE transaction conflicts - safe to retry for concurrent webhooks
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Concurrent processing detected. This is normal for webhook retries.',
            'retry_safe', true,
            'error_reference', extract(epoch from NOW())::bigint
        );
    
    WHEN unique_violation THEN
        -- Idempotency: Payment already processed - this is expected for duplicate webhooks
        RETURN jsonb_build_object(
            'success', true,
            'idempotent', true,
            'message', 'Payment already processed successfully',
            'error_reference', extract(epoch from NOW())::bigint
        );
    
    WHEN OTHERS THEN
        -- Log security-relevant errors without exposing internal details
        BEGIN
            PERFORM public.log_admin_action(
                'payment_processing_error',
                'payment_transactions',
                session_id_param,
                jsonb_build_object(
                    'severity', 'ERROR',
                    'error_type', 'payment_processing_exception',
                    'error_code', SQLSTATE,
                    'error_message', SQLERRM,
                    'user_id', current_user_id,
                    'customer_email_hash', encode(digest(customer_email_param, 'sha256'), 'hex'),
                    'product_id', product_id_param,
                    'function_name', 'process_stripe_payment_completion',
                    'timestamp', extract(epoch from NOW()),
                    'context', 'payment_processing'
                )
            );
        EXCEPTION
            WHEN OTHERS THEN
                -- If logging fails, continue with error response
                NULL;
        END;
        
        -- TEMPORARY DEBUG: Return detailed error information for troubleshooting
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Payment processing failed: ' || COALESCE(SQLERRM, 'Unknown database error'),
            'error_code', SQLSTATE,
            'error_details', jsonb_build_object(
                'sqlstate', SQLSTATE,
                'error_message', SQLERRM,
                'session_id', session_id_param,
                'product_id', product_id_param,
                'user_id', current_user_id,
                'customer_email', customer_email_param,
                'amount', amount_total,
                'currency', currency_param,
                'function', 'process_stripe_payment_completion',
                'timestamp', NOW()
            ),
            'error_reference', extract(epoch from NOW())::bigint,
            'retry_safe', CASE 
                WHEN SQLSTATE LIKE '08%' THEN true  -- Connection errors
                WHEN SQLSTATE LIKE '53%' THEN true  -- Resource errors
                WHEN SQLSTATE LIKE '57%' THEN true  -- Operator intervention
                ELSE false
            END
        );
END;
$_$;


ALTER FUNCTION "public"."process_stripe_payment_completion"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_stripe_payment_completion_with_bump"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text" DEFAULT NULL::"text", "user_id_param" "uuid" DEFAULT NULL::"uuid", "bump_product_id_param" "uuid" DEFAULT NULL::"uuid", "coupon_id_param" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    SET "statement_timeout" TO '30s'
    AS $_$
DECLARE
  current_user_id UUID;
  product_record RECORD;
  bump_product_record RECORD;
  existing_user_id UUID;
  access_expires_at TIMESTAMPTZ := NULL;
  bump_access_expires_at TIMESTAMPTZ := NULL;
  bump_found BOOLEAN := false;
  transaction_id_var UUID;
BEGIN
  bump_product_record := NULL;
  bump_found := false;

  -- Rate limiting
  IF NOT public.check_rate_limit('process_stripe_payment_completion', 100, 3600) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Rate limit exceeded');
  END IF;

  -- Input validation
  IF session_id_param IS NULL OR length(session_id_param) = 0 OR length(session_id_param) > 255 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid session ID');
  END IF;

  -- Accept both Checkout Session (cs_) and Payment Intent (pi_) formats
  IF NOT (session_id_param ~* '^(cs_|pi_)[a-zA-Z0-9_]+$') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid session ID format');
  END IF;

  IF product_id_param IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Product ID is required');
  END IF;

  IF NOT public.validate_email_format(customer_email_param) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Valid email address is required');
  END IF;

  IF amount_total IS NULL OR amount_total <= 0 OR amount_total > 99999999 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid amount');
  END IF;

  -- Authorization
  IF user_id_param IS NOT NULL THEN
    IF (select auth.role()) = 'service_role' THEN
      current_user_id := user_id_param;
    ELSIF auth.uid() = user_id_param THEN
      current_user_id := user_id_param;
    ELSE
      RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
    END IF;
  ELSE
    current_user_id := NULL;
  END IF;

  -- Idempotency check
  IF EXISTS (SELECT 1 FROM public.payment_transactions WHERE session_id = session_id_param) THEN
    -- Check if this was a guest purchase to return consistent values
    IF EXISTS (SELECT 1 FROM public.guest_purchases WHERE session_id = session_id_param) THEN
      -- Guest purchase - return same values as original guest purchase scenario
      RETURN jsonb_build_object(
        'success', true,
        'scenario', 'guest_purchase_new_user_with_bump',
        'access_granted', false,
        'is_guest_purchase', true,
        'send_magic_link', true,
        'customer_email', customer_email_param,
        'message', 'Payment already processed (idempotent)'
      );
    ELSE
      -- Logged-in user purchase
      RETURN jsonb_build_object(
        'success', true,
        'scenario', 'already_processed_idempotent',
        'access_granted', true,
        'already_had_access', true,
        'message', 'Payment already processed (idempotent)'
      );
    END IF;
  END IF;

  -- Get product with price and currency for validation
  SELECT id, auto_grant_duration_days, price, currency INTO product_record
  FROM public.products
  WHERE id = product_id_param AND is_active = true;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Product not found or inactive');
  END IF;

  -- SECURITY: Validate currency matches product currency
  IF product_record.currency IS NOT NULL THEN
    IF upper(currency_param) != upper(product_record.currency) THEN
      RAISE EXCEPTION 'Currency mismatch: expected %, got %',
        product_record.currency, currency_param;
    END IF;
  END IF;

  -- Get bump product if provided (with price for validation)
  IF bump_product_id_param IS NOT NULL THEN
    SELECT
      p.id,
      COALESCE(ob.access_duration_days, p.auto_grant_duration_days) as auto_grant_duration_days,
      COALESCE(ob.bump_price, p.price) as price,
      p.currency
    INTO bump_product_record
    FROM public.products p
    JOIN public.order_bumps ob ON ob.bump_product_id = p.id AND ob.main_product_id = product_id_param
    WHERE p.id = bump_product_id_param AND p.is_active = true;

    IF FOUND THEN
      bump_found := true;
    END IF;
  END IF;

  -- SECURITY: Validate amount matches product price (prevent price manipulation)
  -- Check total: main product + bump (if present), accounting for coupons
  -- Skip validation if product has no fixed price (PWYW - Pay What You Want)
  -- NOTE: Stripe sends amount_total AFTER applying coupon discount, so we need to
  --       account for that. However, we can't validate exact amount with coupons
  --       because we don't have coupon details at this point (only coupon_id).
  --       The coupon was already validated in verify_coupon() and reserved.
  --       We only validate that amount is reasonable (not manipulated to zero or negative).
  IF product_record.price IS NOT NULL THEN
    DECLARE
      bump_price NUMERIC := NULL;
    BEGIN
      -- Extract bump price if bump was found
      IF bump_found THEN
        bump_price := bump_product_record.price;
      END IF;

      IF coupon_id_param IS NULL THEN
        -- No coupon: validate exact amount
        IF bump_price IS NOT NULL THEN
          -- Validate: amount = main product + bump product
          IF amount_total != ((product_record.price + bump_price) * 100) THEN
            RAISE EXCEPTION 'Amount mismatch with bump: expected % cents (product % + bump %), got % cents',
              ((product_record.price + bump_price) * 100),
              (product_record.price * 100),
              (bump_price * 100),
              amount_total;
          END IF;
        ELSE
          -- Validate: amount = main product only (no bump or bump has no price)
          IF amount_total != (product_record.price * 100) THEN
            RAISE EXCEPTION 'Amount mismatch: expected % cents, got % cents',
              (product_record.price * 100), amount_total;
          END IF;
        END IF;
      ELSE
        -- Coupon applied: only validate amount is reasonable (not zero/negative/too high)
        -- Cannot validate exact amount without fetching coupon details
        IF amount_total <= 0 THEN
          RAISE EXCEPTION 'Invalid amount with coupon: amount cannot be zero or negative';
        END IF;

        IF bump_price IS NOT NULL THEN
          IF amount_total > ((product_record.price + bump_price) * 100) THEN
            RAISE EXCEPTION 'Amount too high with coupon: got % cents but max possible is % cents',
              amount_total, ((product_record.price + bump_price) * 100);
          END IF;
        ELSE
          IF amount_total > (product_record.price * 100) THEN
            RAISE EXCEPTION 'Amount too high with coupon: got % cents but max possible is % cents',
              amount_total, (product_record.price * 100);
          END IF;
        END IF;
      END IF;
    END;
  END IF;

  -- Find existing user
  SELECT id INTO existing_user_id FROM auth.users WHERE email = customer_email_param;

  -- Calculate expiration
  IF product_record.auto_grant_duration_days IS NOT NULL THEN
    access_expires_at := NOW() + (product_record.auto_grant_duration_days || ' days')::INTERVAL;
  END IF;

  IF bump_found THEN
    IF bump_product_record.auto_grant_duration_days IS NOT NULL AND bump_product_record.auto_grant_duration_days > 0 THEN
      bump_access_expires_at := NOW() + (bump_product_record.auto_grant_duration_days || ' days')::INTERVAL;
    ELSE
      bump_access_expires_at := NULL;
    END IF;
  END IF;

  BEGIN
    -- Record transaction
    INSERT INTO public.payment_transactions (
      session_id, user_id, product_id, customer_email, amount, currency,
      stripe_payment_intent_id, status, metadata
    ) VALUES (
      session_id_param, current_user_id, product_id_param, customer_email_param,
      amount_total, upper(currency_param), stripe_payment_intent_id, 'completed',
      jsonb_build_object(
        'has_bump', bump_found,
        'bump_product_id', bump_product_id_param,
        'has_coupon', coupon_id_param IS NOT NULL,
        'coupon_id', coupon_id_param
      )
    ) RETURNING id INTO transaction_id_var;

    -- Increment sale quantity sold if sale price is active
    -- This is done atomically to prevent race conditions
    PERFORM public.increment_sale_quantity_sold(product_id_param);

    -- SECURITY FIX: Handle coupon redemption with reservation system
    IF coupon_id_param IS NOT NULL THEN
      -- STEP 1: Verify and consume reservation
      DELETE FROM public.coupon_reservations
      WHERE coupon_id = coupon_id_param
        AND customer_email = customer_email_param
        AND expires_at > NOW();

      IF NOT FOUND THEN
        -- No valid reservation - this should not happen if frontend uses verify_coupon first
        -- But we handle it gracefully: reject the payment
        RAISE EXCEPTION 'No valid coupon reservation found. Coupon may have expired or reached limit.';
      END IF;

      -- STEP 2: Atomic increment (reservation guarantees this will succeed)
      -- We still do atomic check as defense-in-depth
      UPDATE public.coupons
      SET current_usage_count = COALESCE(current_usage_count, 0) + 1
      WHERE id = coupon_id_param
        AND is_active = true
        AND (usage_limit_global IS NULL OR COALESCE(current_usage_count, 0) < usage_limit_global);

      IF NOT FOUND THEN
        -- This should never happen if reservation system works correctly
        -- But if it does, we handle it gracefully
        RAISE EXCEPTION 'Coupon limit reached despite reservation (system error)';
      END IF;

      -- STEP 3: Record redemption
      INSERT INTO public.coupon_redemptions (
        coupon_id, user_id, customer_email, transaction_id, discount_amount
      ) VALUES (
        coupon_id_param,
        COALESCE(current_user_id, existing_user_id),
        customer_email_param,
        transaction_id_var,
        0
      );
    END IF;

    -- SCENARIO 1: Logged-in user
    IF current_user_id IS NOT NULL THEN
      PERFORM public.grant_product_access_service_role(current_user_id, product_id_param);
      IF bump_found THEN
        PERFORM public.grant_product_access_service_role(current_user_id, bump_product_id_param);
      END IF;

      RETURN jsonb_build_object(
        'success', true,
        'scenario', 'logged_in_user_with_bump',
        'access_granted', true,
        'bump_access_granted', bump_found,
        'customer_email', customer_email_param
      );

    -- SCENARIO 2: Guest purchase, user exists
    ELSIF existing_user_id IS NOT NULL THEN
      INSERT INTO public.guest_purchases (customer_email, product_id, transaction_amount, session_id)
      VALUES (customer_email_param, product_id_param, amount_total, session_id_param);

      IF bump_found THEN
        INSERT INTO public.guest_purchases (customer_email, product_id, transaction_amount, session_id)
        VALUES (customer_email_param, bump_product_id_param, 0, session_id_param || '_bump');
      END IF;

      RETURN jsonb_build_object(
        'success', true,
        'scenario', 'guest_purchase_user_exists_with_bump',
        'access_granted', false,
        'is_guest_purchase', true,
        'send_magic_link', true,
        'customer_email', customer_email_param
      );

    -- SCENARIO 3: Guest purchase, new user
    ELSE
      INSERT INTO public.guest_purchases (customer_email, product_id, transaction_amount, session_id)
      VALUES (customer_email_param, product_id_param, amount_total, session_id_param);

      IF bump_found THEN
        INSERT INTO public.guest_purchases (customer_email, product_id, transaction_amount, session_id)
        VALUES (customer_email_param, bump_product_id_param, 0, session_id_param || '_bump');
      END IF;

      RETURN jsonb_build_object(
        'success', true,
        'scenario', 'guest_purchase_new_user_with_bump',
        'access_granted', false,
        'is_guest_purchase', true,
        'send_magic_link', true,
        'customer_email', customer_email_param
      );
    END IF;

  EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Database Error: ' || SQLERRM,
      'code', SQLSTATE
    );
  END;
END;
$_$;


ALTER FUNCTION "public"."process_stripe_payment_completion_with_bump"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid", "bump_product_id_param" "uuid", "coupon_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."send_monitoring_email"("alert_type" "text", "alert_details" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '1s'
    AS $$
BEGIN
    -- Security check: Only allow service_role and authenticated users
    IF (select auth.role()) NOT IN ('service_role', 'authenticated') THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;
    
    -- TODO: Integrate with email service (SMTP, SendGrid, etc.)
    -- For now, we'll use pg_notify to send to external service
    
    PERFORM pg_notify(
        'monitoring_alerts',
        jsonb_build_object(
            'alert_type', alert_type,
            'alert_details', alert_details,
            'timestamp', extract(epoch from NOW()),
            'urgent', CASE 
                WHEN alert_type = 'critical_errors' THEN true
                ELSE false
            END
        )::text
    );
    
EXCEPTION 
    WHEN OTHERS THEN
        -- If email fails, don't break anything
        NULL;
END;
$$;


ALTER FUNCTION "public"."send_monitoring_email"("alert_type" "text", "alert_details" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_revenue_goal"("p_goal_amount" bigint, "p_start_date" timestamp with time zone, "p_product_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()) THEN
    RAISE EXCEPTION 'Access denied';
  END IF;

  IF p_product_id IS NULL THEN
    INSERT INTO public.revenue_goals (product_id, goal_amount, start_date, updated_at)
    VALUES (NULL, p_goal_amount, p_start_date, NOW())
    ON CONFLICT ((1)) WHERE product_id IS NULL
    DO UPDATE SET
      goal_amount = EXCLUDED.goal_amount,
      start_date = EXCLUDED.start_date,
      updated_at = NOW();
  ELSE
    INSERT INTO public.revenue_goals (product_id, goal_amount, start_date, updated_at)
    VALUES (p_product_id, p_goal_amount, p_start_date, NOW())
    ON CONFLICT (product_id) WHERE product_id IS NOT NULL
    DO UPDATE SET
      goal_amount = EXCLUDED.goal_amount,
      start_date = EXCLUDED.start_date,
      updated_at = NOW();
  END IF;
END;
$$;


ALTER FUNCTION "public"."set_revenue_goal"("p_goal_amount" bigint, "p_start_date" timestamp with time zone, "p_product_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_refund_request_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_refund_request_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_refunded_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
    IF NEW.status = 'refunded' AND OLD.status != 'refunded' THEN
        NEW.refunded_at = NOW();
        -- Note: Admin action logging is handled by the log_admin_action() trigger
        -- which runs AFTER this trigger and captures the complete state change
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_refunded_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_video_progress"("product_id_param" "uuid", "video_id_param" "text", "position_param" integer, "duration_param" integer DEFAULT NULL::integer, "completed_param" boolean DEFAULT false) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  current_user_id UUID := auth.uid();
  progress_record RECORD;
BEGIN
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  INSERT INTO public.video_progress (
    user_id, product_id, video_id, last_position_seconds,
    max_position_seconds, video_duration_seconds, is_completed
  ) VALUES (
    current_user_id, product_id_param, video_id_param, position_param,
    position_param, duration_param, completed_param
  )
  ON CONFLICT (user_id, product_id, video_id) DO UPDATE SET
    last_position_seconds = position_param,
    max_position_seconds = GREATEST(video_progress.max_position_seconds, position_param),
    video_duration_seconds = COALESCE(duration_param, video_progress.video_duration_seconds),
    is_completed = video_progress.is_completed OR completed_param,
    view_count = video_progress.view_count + CASE WHEN position_param = 0 THEN 1 ELSE 0 END,
    updated_at = NOW()
  RETURNING * INTO progress_record;

  RETURN jsonb_build_object(
    'success', true,
    'id', progress_record.id,
    'last_position', progress_record.last_position_seconds,
    'is_completed', progress_record.is_completed
  );
END;
$$;


ALTER FUNCTION "public"."update_video_progress"("product_id_param" "uuid", "video_id_param" "text", "position_param" integer, "duration_param" integer, "completed_param" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_email_format"("email_param" "text") RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '5s'
    AS $_$
BEGIN
    -- Input validation
    IF email_param IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Length check (RFC 5321)
    IF length(email_param) < 3 OR length(email_param) > 254 THEN
        RETURN FALSE;
    END IF;
    
    -- Basic format validation with simplified but robust regex
    -- This pattern is more maintainable and covers most real-world cases
    IF NOT (email_param ~* '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$') THEN
        RETURN FALSE;
    END IF;
    
    -- Additional security checks
    IF email_param LIKE '%..%' OR     -- Consecutive dots
       email_param LIKE '.%' OR       -- Starting with dot
       email_param LIKE '%.' OR       -- Ending with dot
       email_param LIKE '%@.%' OR     -- Dot immediately after @
       email_param LIKE '%.@%' THEN   -- Dot immediately before @
        RETURN FALSE;
    END IF;
    
    -- Check for multiple @ symbols
    IF (length(email_param) - length(replace(email_param, '@', ''))) != 1 THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$_$;


ALTER FUNCTION "public"."validate_email_format"("email_param" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_payment_transaction"("transaction_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    SET "statement_timeout" TO '2s'
    AS $$
DECLARE
    transaction_record RECORD;
    current_user_id UUID;
BEGIN
    -- Enhanced UUID validation
    IF transaction_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Check for null UUID or invalid patterns
    IF transaction_id = '00000000-0000-0000-0000-000000000000'::UUID THEN
        RETURN FALSE; -- Reject null UUID
    END IF;
    
    -- Additional validation: ensure UUID string format is canonical
    -- PostgreSQL automatically validates UUID format on cast, but this adds extra safety
    BEGIN
        -- This will raise an exception if transaction_id cannot be converted to text and back
        IF (transaction_id::TEXT)::UUID != transaction_id THEN
            RETURN FALSE;
        END IF;
    EXCEPTION WHEN OTHERS THEN
        RETURN FALSE; -- Invalid UUID format or conversion error
    END;
    
    -- Get current user
    current_user_id := auth.uid();
    
    -- Get transaction with access control
    SELECT * INTO transaction_record
    FROM public.payment_transactions
    WHERE id = transaction_id
      AND (
        -- User can validate their own transactions
        user_id = current_user_id OR
        -- Admins can validate any transaction
        EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = current_user_id) OR
        -- Service role can validate any transaction
        (select auth.role()) = 'service_role'
      );
    
    IF NOT FOUND THEN
        RETURN FALSE; -- Transaction not found or access denied
    END IF;
    
    -- Validate transaction integrity
    IF transaction_record.amount <= 0 THEN
        RETURN FALSE;
    END IF;
    
    IF transaction_record.refunded_amount > transaction_record.amount THEN
        RETURN FALSE;
    END IF;
    
    IF transaction_record.status = 'refunded' AND transaction_record.refunded_at IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Validate refunded_amount is non-negative
    IF transaction_record.refunded_amount < 0 THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."validate_payment_transaction"("transaction_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."verify_api_key"("p_key_hash" "text") RETURNS TABLE("key_id" "uuid", "admin_user_id" "uuid", "scopes" "jsonb", "rate_limit_per_minute" integer, "is_valid" boolean, "rejection_reason" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_key RECORD;
BEGIN
  -- Find the key
  SELECT * INTO v_key
  FROM api_keys ak
  WHERE ak.key_hash = p_key_hash;

  -- Key not found
  IF NOT FOUND THEN
    RETURN QUERY SELECT
      NULL::UUID, NULL::UUID, NULL::JSONB, NULL::INTEGER,
      false, 'Invalid API key'::TEXT;
    RETURN;
  END IF;

  -- Key is not active
  IF NOT v_key.is_active THEN
    -- Check if it's in rotation grace period
    IF v_key.rotation_grace_until IS NOT NULL AND v_key.rotation_grace_until > NOW() THEN
      -- Still in grace period, allow
    ELSE
      RETURN QUERY SELECT
        v_key.id, v_key.admin_user_id, v_key.scopes, v_key.rate_limit_per_minute,
        false, 'API key has been revoked'::TEXT;
      RETURN;
    END IF;
  END IF;

  -- Key has expired
  IF v_key.expires_at IS NOT NULL AND v_key.expires_at < NOW() THEN
    RETURN QUERY SELECT
      v_key.id, v_key.admin_user_id, v_key.scopes, v_key.rate_limit_per_minute,
      false, 'API key has expired'::TEXT;
    RETURN;
  END IF;

  -- Update usage stats (non-blocking)
  UPDATE api_keys
  SET
    last_used_at = NOW(),
    usage_count = usage_count + 1
  WHERE id = v_key.id;

  -- Key is valid
  RETURN QUERY SELECT
    v_key.id, v_key.admin_user_id, v_key.scopes, v_key.rate_limit_per_minute,
    true, NULL::TEXT;
END;
$$;


ALTER FUNCTION "public"."verify_api_key"("p_key_hash" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."verify_coupon"("code_param" "text", "product_id_param" "uuid", "customer_email_param" "text" DEFAULT NULL::"text", "currency_param" "text" DEFAULT 'USD'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  coupon_record RECORD;
  user_usage_count INTEGER;
  reserved_count INTEGER;
  available_slots INTEGER;
  existing_reservation_id UUID;
BEGIN
  -- STEP 1: Self-cleaning - remove expired reservations
  -- This happens automatically on every verify call (no cron needed!)
  DELETE FROM public.coupon_reservations WHERE expires_at < NOW();

  -- STEP 2: Lock coupon row (must use FOR UPDATE to ensure atomicity)
  SELECT * INTO coupon_record
  FROM public.coupons
  WHERE code = code_param AND is_active = true
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Invalid code');
  END IF;

  IF coupon_record.expires_at IS NOT NULL AND coupon_record.expires_at < NOW() THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Code expired');
  END IF;

  IF coupon_record.starts_at > NOW() THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Code not active yet');
  END IF;

  IF coupon_record.discount_type = 'fixed' AND coupon_record.currency IS NOT NULL AND coupon_record.currency != currency_param THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Code invalid for this currency');
  END IF;

  IF jsonb_array_length(coupon_record.allowed_product_ids) > 0 THEN
    IF NOT (coupon_record.allowed_product_ids @> to_jsonb(product_id_param)) THEN
      RETURN jsonb_build_object('valid', false, 'error', 'Code not valid for this product');
    END IF;
  END IF;

  IF jsonb_array_length(coupon_record.allowed_emails) > 0 THEN
    IF customer_email_param IS NULL OR NOT (coupon_record.allowed_emails @> to_jsonb(customer_email_param)) THEN
      RETURN jsonb_build_object('valid', false, 'error', 'Code not authorized for this email');
    END IF;
  END IF;

  -- STEP 3: Check per-user limit (actual redemptions)
  IF customer_email_param IS NOT NULL THEN
    SELECT COUNT(*) INTO user_usage_count
    FROM public.coupon_redemptions
    WHERE coupon_id = coupon_record.id AND customer_email = customer_email_param;

    IF user_usage_count >= coupon_record.usage_limit_per_user THEN
      RETURN jsonb_build_object('valid', false, 'error', 'You have already used this code');
    END IF;
  END IF;

  -- STEP 4: Check if user already has an active reservation
  IF customer_email_param IS NOT NULL THEN
    SELECT id INTO existing_reservation_id
    FROM public.coupon_reservations
    WHERE coupon_id = coupon_record.id
      AND customer_email = customer_email_param
      AND expires_at > NOW();

    IF existing_reservation_id IS NOT NULL THEN
      -- User already reserved - return success with existing reservation
      RETURN jsonb_build_object(
        'valid', true,
        'id', coupon_record.id,
        'code', coupon_record.code,
        'discount_type', coupon_record.discount_type,
        'discount_value', coupon_record.discount_value,
        'exclude_order_bumps', coupon_record.exclude_order_bumps,
        'already_reserved', true,
        'reservation_id', existing_reservation_id
      );
    END IF;
  END IF;

  -- STEP 5: Calculate available slots (global limit with reservations)
  IF coupon_record.usage_limit_global IS NOT NULL THEN
    -- Count active reservations
    SELECT COUNT(*) INTO reserved_count
    FROM public.coupon_reservations
    WHERE coupon_id = coupon_record.id AND expires_at > NOW();

    -- Available = limit - redemptions - reservations
    available_slots := coupon_record.usage_limit_global
                     - coupon_record.current_usage_count
                     - reserved_count;

    IF available_slots <= 0 THEN
      RETURN jsonb_build_object('valid', false, 'error', 'Code usage limit reached');
    END IF;
  END IF;

  -- STEP 6: CREATE RESERVATION (15 minute expiry)
  IF customer_email_param IS NOT NULL THEN
    INSERT INTO public.coupon_reservations (
      coupon_id,
      customer_email,
      expires_at
    ) VALUES (
      coupon_record.id,
      customer_email_param,
      NOW() + INTERVAL '15 minutes'
    )
    ON CONFLICT (coupon_id, customer_email) DO UPDATE
    SET expires_at = NOW() + INTERVAL '15 minutes',
        reserved_at = NOW();
  END IF;

  RETURN jsonb_build_object(
    'valid', true,
    'id', coupon_record.id,
    'code', coupon_record.code,
    'discount_type', coupon_record.discount_type,
    'discount_value', coupon_record.discount_value,
    'exclude_order_bumps', coupon_record.exclude_order_bumps,
    'reserved', true,
    'expires_in_minutes', 15
  );
END;
$$;


ALTER FUNCTION "public"."verify_coupon"("code_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "currency_param" "text") OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."admin_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_id" "uuid",
    "action" character varying(100) NOT NULL,
    "target_type" character varying(50) NOT NULL,
    "target_id" character varying(255) NOT NULL,
    "details" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "admin_actions_action_check" CHECK ((("length"(("action")::"text") >= 1) AND ("length"(("action")::"text") <= 100))),
    CONSTRAINT "admin_actions_target_id_check" CHECK ((("length"(("target_id")::"text") >= 1) AND ("length"(("target_id")::"text") <= 255))),
    CONSTRAINT "admin_actions_target_type_check" CHECK ((("length"(("target_type")::"text") >= 1) AND ("length"(("target_type")::"text") <= 50)))
);


ALTER TABLE "public"."admin_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."admin_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."api_key_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "api_key_id" "uuid",
    "event_type" "text" NOT NULL,
    "event_data" "jsonb" DEFAULT '{}'::"jsonb",
    "ip_address" "inet",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "api_key_audit_log_event_type_check" CHECK (("event_type" = ANY (ARRAY['created'::"text", 'rotated'::"text", 'revoked'::"text", 'expired'::"text", 'used_after_revoke'::"text"])))
);


ALTER TABLE "public"."api_key_audit_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."api_key_audit_log" IS 'Audit trail for API key lifecycle events';



CREATE TABLE IF NOT EXISTS "public"."api_keys" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "key_prefix" "text" NOT NULL,
    "key_hash" "text" NOT NULL,
    "admin_user_id" "uuid" NOT NULL,
    "scopes" "jsonb" DEFAULT '["*"]'::"jsonb" NOT NULL,
    "rate_limit_per_minute" integer DEFAULT 60,
    "is_active" boolean DEFAULT true NOT NULL,
    "expires_at" timestamp with time zone,
    "last_used_at" timestamp with time zone,
    "last_used_ip" "inet",
    "usage_count" bigint DEFAULT 0 NOT NULL,
    "rotated_from_id" "uuid",
    "rotation_grace_until" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "revoked_at" timestamp with time zone,
    "revoked_reason" "text",
    CONSTRAINT "api_keys_key_prefix_check" CHECK (("length"("key_prefix") = 12)),
    CONSTRAINT "api_keys_name_check" CHECK ((("length"("name") >= 1) AND ("length"("name") <= 100))),
    CONSTRAINT "api_keys_rate_limit_per_minute_check" CHECK ((("rate_limit_per_minute" > 0) AND ("rate_limit_per_minute" <= 1000))),
    CONSTRAINT "api_keys_revoked_reason_check" CHECK ((("revoked_reason" IS NULL) OR ("length"("revoked_reason") <= 500))),
    CONSTRAINT "check_revoked_consistency" CHECK (((("is_active" = true) AND ("revoked_at" IS NULL)) OR ("is_active" = false)))
);


ALTER TABLE "public"."api_keys" OWNER TO "postgres";


COMMENT ON TABLE "public"."api_keys" IS 'API keys for external authentication (MCP Server, integrations, external developers)';



COMMENT ON COLUMN "public"."api_keys"."key_prefix" IS 'First 12 characters of the key for identification (shown in UI)';



COMMENT ON COLUMN "public"."api_keys"."key_hash" IS 'SHA-256 hash of the full API key - never store plaintext';



COMMENT ON COLUMN "public"."api_keys"."scopes" IS 'JSON array of permission scopes. Use "*" for full access';



COMMENT ON COLUMN "public"."api_keys"."rotation_grace_until" IS 'During key rotation, old key remains valid until this timestamp';



CREATE TABLE IF NOT EXISTS "public"."application_rate_limits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "identifier" "text" NOT NULL,
    "action_type" "text" NOT NULL,
    "window_start" timestamp with time zone NOT NULL,
    "call_count" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."application_rate_limits" OWNER TO "postgres";


COMMENT ON TABLE "public"."application_rate_limits" IS 'Rate limiting for application-level API routes (Next.js) - separate from internal RPC rate limiting';



CREATE TABLE IF NOT EXISTS "public"."audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "table_name" "text" NOT NULL,
    "operation" "text" NOT NULL,
    "old_values" "jsonb",
    "new_values" "jsonb",
    "user_id" "uuid",
    "performed_by" "uuid",
    "performed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ip_address" "inet",
    "user_agent" "text",
    CONSTRAINT "audit_log_operation_check" CHECK (("operation" = ANY (ARRAY['INSERT'::"text", 'UPDATE'::"text", 'DELETE'::"text"])))
);


ALTER TABLE "public"."audit_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text",
    "parent_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "categories_description_check" CHECK (("length"("description") <= 500)),
    CONSTRAINT "categories_name_check" CHECK (("length"("name") <= 100)),
    CONSTRAINT "categories_slug_check" CHECK ((("slug" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("slug") >= 1) AND ("length"("slug") <= 100))))
);


ALTER TABLE "public"."categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."consent_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "anonymous_id" "text",
    "ip_address" "text",
    "user_agent" "text",
    "consent_version" "text",
    "consents" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."consent_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coupon_redemptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "coupon_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "customer_email" "text" NOT NULL,
    "transaction_id" "uuid",
    "discount_amount" numeric NOT NULL,
    "redeemed_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."coupon_redemptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coupon_reservations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "coupon_id" "uuid" NOT NULL,
    "customer_email" "text" NOT NULL,
    "reserved_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "session_id" "text"
);


ALTER TABLE "public"."coupon_reservations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coupons" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text",
    "discount_type" "text" NOT NULL,
    "discount_value" numeric NOT NULL,
    "currency" "text",
    "allowed_emails" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "allowed_product_ids" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "exclude_order_bumps" boolean DEFAULT false NOT NULL,
    "usage_limit_global" integer,
    "usage_limit_per_user" integer DEFAULT 1,
    "current_usage_count" integer DEFAULT 0 NOT NULL,
    "starts_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone,
    "is_active" boolean DEFAULT true NOT NULL,
    "is_public" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_oto_coupon" boolean DEFAULT false NOT NULL,
    "oto_offer_id" "uuid",
    "source_transaction_id" "uuid",
    CONSTRAINT "coupons_check" CHECK (((("discount_type" = 'fixed'::"text") AND (("currency" IS NULL) OR ("length"("currency") = 3))) OR (("discount_type" = 'percentage'::"text") AND ("currency" IS NULL)))),
    CONSTRAINT "coupons_code_check" CHECK (("length"("code") >= 3)),
    CONSTRAINT "coupons_discount_type_check" CHECK (("discount_type" = ANY (ARRAY['percentage'::"text", 'fixed'::"text"]))),
    CONSTRAINT "coupons_discount_value_check" CHECK (("discount_value" > (0)::numeric)),
    CONSTRAINT "valid_percentage" CHECK ((("discount_type" <> 'percentage'::"text") OR ("discount_value" <= (100)::numeric)))
);


ALTER TABLE "public"."coupons" OWNER TO "postgres";


COMMENT ON TABLE "public"."coupons" IS 'Smart discount codes with auto-apply and targeting';



COMMENT ON COLUMN "public"."coupons"."is_oto_coupon" IS 'True if this coupon was auto-generated by the OTO system';



COMMENT ON COLUMN "public"."coupons"."oto_offer_id" IS 'Reference to the OTO offer that generated this coupon';



COMMENT ON COLUMN "public"."coupons"."source_transaction_id" IS 'The transaction that triggered OTO coupon generation';



CREATE TABLE IF NOT EXISTS "public"."custom_scripts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "script_location" "text" NOT NULL,
    "script_content" "text" NOT NULL,
    "category" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "custom_scripts_category_check" CHECK (("category" = ANY (ARRAY['essential'::"text", 'analytics'::"text", 'marketing'::"text"]))),
    CONSTRAINT "custom_scripts_script_location_check" CHECK (("script_location" = ANY (ARRAY['head'::"text", 'body'::"text"])))
);


ALTER TABLE "public"."custom_scripts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."guest_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "customer_email" "text" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "transaction_amount" numeric NOT NULL,
    "session_id" "text" NOT NULL,
    "claimed_by_user_id" "uuid",
    "claimed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    CONSTRAINT "guest_purchases_customer_email_check" CHECK ("public"."validate_email_format"("customer_email")),
    CONSTRAINT "guest_purchases_session_id_check" CHECK (((("length"("session_id") >= 1) AND ("length"("session_id") <= 255)) AND ("session_id" ~* '^(cs_|pi_)[a-zA-Z0-9_]+$'::"text"))),
    CONSTRAINT "guest_purchases_transaction_amount_check" CHECK ((("transaction_amount" >= (0)::numeric) AND ("transaction_amount" <= (99999999)::numeric)))
);


ALTER TABLE "public"."guest_purchases" OWNER TO "postgres";


COMMENT ON COLUMN "public"."guest_purchases"."metadata" IS 'Additional purchase metadata (e.g., NIP, company details from GUS, invoice information)';



CREATE TABLE IF NOT EXISTS "public"."integrations_config" (
    "id" integer DEFAULT 1 NOT NULL,
    "gtm_container_id" "text",
    "gtm_server_container_url" "text",
    "facebook_pixel_id" "text",
    "facebook_capi_token" "text",
    "facebook_test_event_code" "text",
    "fb_capi_enabled" boolean DEFAULT false,
    "send_conversions_without_consent" boolean DEFAULT false,
    "google_ads_conversion_id" "text",
    "google_ads_conversion_label" "text",
    "umami_website_id" "text",
    "umami_script_url" "text" DEFAULT 'https://cloud.umami.is/script.js'::"text",
    "currency_api_provider" "text" DEFAULT 'ecb'::"text",
    "currency_api_key_encrypted" "text",
    "currency_api_key_iv" "text",
    "currency_api_key_tag" "text",
    "currency_api_enabled" boolean DEFAULT true NOT NULL,
    "cookie_consent_enabled" boolean DEFAULT true,
    "consent_logging_enabled" boolean DEFAULT false,
    "gateflow_license" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "gus_api_key_encrypted" "text",
    "gus_api_key_iv" "text",
    "gus_api_key_tag" "text",
    "gus_api_enabled" boolean DEFAULT false NOT NULL,
    CONSTRAINT "integrations_config_currency_api_provider_check" CHECK (("currency_api_provider" = ANY (ARRAY['exchangerate-api'::"text", 'fixer'::"text", 'ecb'::"text"]))),
    CONSTRAINT "integrations_config_id_check" CHECK (("id" = 1))
);


ALTER TABLE "public"."integrations_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."integrations_config" IS 'Global integrations configuration (singleton)';



COMMENT ON COLUMN "public"."integrations_config"."currency_api_provider" IS 'Currency exchange rate provider: ecb (free EU, default), exchangerate-api (free 1500/mo), or fixer (paid)';



COMMENT ON COLUMN "public"."integrations_config"."currency_api_key_encrypted" IS 'AES-256-GCM encrypted Currency API key (base64 encoded) - for ExchangeRate-API or Fixer.io';



COMMENT ON COLUMN "public"."integrations_config"."currency_api_key_iv" IS 'Initialization vector for Currency API key decryption (base64 encoded)';



COMMENT ON COLUMN "public"."integrations_config"."currency_api_key_tag" IS 'Authentication tag for Currency API key decryption (base64 encoded)';



COMMENT ON COLUMN "public"."integrations_config"."currency_api_enabled" IS 'Whether Currency API integration is enabled for exchange rate fetching';



COMMENT ON COLUMN "public"."integrations_config"."gus_api_key_encrypted" IS 'AES-256-GCM encrypted GUS REGON API key (base64 encoded)';



COMMENT ON COLUMN "public"."integrations_config"."gus_api_key_iv" IS 'Initialization vector for GUS API key decryption (base64 encoded)';



COMMENT ON COLUMN "public"."integrations_config"."gus_api_key_tag" IS 'Authentication tag for GUS API key decryption (base64 encoded)';



COMMENT ON COLUMN "public"."integrations_config"."gus_api_enabled" IS 'Whether GUS API integration is enabled for automatic company data fetching';



CREATE TABLE IF NOT EXISTS "public"."order_bumps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "main_product_id" "uuid" NOT NULL,
    "bump_product_id" "uuid" NOT NULL,
    "bump_price" numeric,
    "bump_title" "text" NOT NULL,
    "bump_description" "text",
    "display_order" integer DEFAULT 0 NOT NULL,
    "access_duration_days" integer,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "no_self_bump" CHECK (("main_product_id" <> "bump_product_id")),
    CONSTRAINT "order_bumps_access_duration_days_check" CHECK ((("access_duration_days" IS NULL) OR ("access_duration_days" >= 0))),
    CONSTRAINT "order_bumps_bump_description_check" CHECK ((("bump_description" IS NULL) OR ("length"("bump_description") <= 1000))),
    CONSTRAINT "order_bumps_bump_price_check" CHECK ((("bump_price" IS NULL) OR ("bump_price" >= (0)::numeric))),
    CONSTRAINT "order_bumps_bump_title_check" CHECK ((("length"("bump_title") >= 1) AND ("length"("bump_title") <= 255)))
);


ALTER TABLE "public"."order_bumps" OWNER TO "postgres";


COMMENT ON TABLE "public"."order_bumps" IS 'Order bump configurations for one-click upsells';



COMMENT ON COLUMN "public"."order_bumps"."bump_price" IS 'Special discounted price for bump (NULL = use product default price)';



CREATE TABLE IF NOT EXISTS "public"."oto_offers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_product_id" "uuid" NOT NULL,
    "oto_product_id" "uuid" NOT NULL,
    "discount_type" "text" NOT NULL,
    "discount_value" numeric NOT NULL,
    "duration_minutes" integer DEFAULT 15 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "display_order" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "no_self_oto" CHECK (("source_product_id" <> "oto_product_id")),
    CONSTRAINT "oto_offers_discount_type_check" CHECK (("discount_type" = ANY (ARRAY['percentage'::"text", 'fixed'::"text"]))),
    CONSTRAINT "oto_offers_discount_value_check" CHECK (("discount_value" > (0)::numeric)),
    CONSTRAINT "oto_offers_duration_minutes_check" CHECK ((("duration_minutes" > 0) AND ("duration_minutes" <= 1440))),
    CONSTRAINT "valid_percentage_discount" CHECK ((("discount_type" <> 'percentage'::"text") OR ("discount_value" <= (100)::numeric)))
);


ALTER TABLE "public"."oto_offers" OWNER TO "postgres";


COMMENT ON TABLE "public"."oto_offers" IS 'OTO (One-Time Offer) configurations - defines which product to offer after purchasing another';



COMMENT ON COLUMN "public"."oto_offers"."source_product_id" IS 'The product that triggers the OTO after purchase';



COMMENT ON COLUMN "public"."oto_offers"."oto_product_id" IS 'The product offered as OTO with a discount';



COMMENT ON COLUMN "public"."oto_offers"."duration_minutes" IS 'How long the OTO coupon is valid (default: 15 minutes, max: 24 hours)';



CREATE TABLE IF NOT EXISTS "public"."payment_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "text" NOT NULL,
    "user_id" "uuid",
    "product_id" "uuid" NOT NULL,
    "customer_email" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "currency" "text" NOT NULL,
    "stripe_payment_intent_id" "text",
    "status" "text" DEFAULT 'completed'::"text" NOT NULL,
    "refunded_amount" numeric DEFAULT 0,
    "refunded_at" timestamp with time zone,
    "refunded_by" "uuid",
    "refund_id" "text",
    "refund_reason" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "payment_transactions_amount_check" CHECK ((("amount" > (0)::numeric) AND ("amount" <= (99999999)::numeric))),
    CONSTRAINT "payment_transactions_currency_check" CHECK ((("length"("currency") = 3) AND ("upper"("currency") ~ '^[A-Z]{3}$'::"text") AND ("upper"("currency") = ANY (ARRAY['USD'::"text", 'EUR'::"text", 'GBP'::"text", 'CAD'::"text", 'AUD'::"text", 'JPY'::"text", 'CHF'::"text", 'CNY'::"text", 'SEK'::"text", 'NOK'::"text", 'DKK'::"text", 'PLN'::"text", 'CZK'::"text", 'HUF'::"text", 'RON'::"text", 'BGN'::"text", 'HRK'::"text", 'RUB'::"text", 'TRY'::"text", 'BRL'::"text", 'MXN'::"text", 'INR'::"text", 'KRW'::"text", 'SGD'::"text", 'HKD'::"text", 'NZD'::"text", 'ZAR'::"text", 'ILS'::"text", 'THB'::"text", 'MYR'::"text", 'PHP'::"text", 'IDR'::"text", 'VND'::"text"])))),
    CONSTRAINT "payment_transactions_customer_email_check" CHECK ("public"."validate_email_format"("customer_email")),
    CONSTRAINT "payment_transactions_refund_id_check" CHECK ((("refund_id" IS NULL) OR ((("length"("refund_id") >= 1) AND ("length"("refund_id") <= 255)) AND ("refund_id" ~* '^re_[a-zA-Z0-9_]+$'::"text")))),
    CONSTRAINT "payment_transactions_refund_reason_check" CHECK ((("refund_reason" IS NULL) OR (("length"("refund_reason") >= 1) AND ("length"("refund_reason") <= 1000)))),
    CONSTRAINT "payment_transactions_refunded_amount_check" CHECK ((("refunded_amount" >= (0)::numeric) AND ("refunded_amount" IS NOT NULL))),
    CONSTRAINT "payment_transactions_session_id_check" CHECK (((("length"("session_id") >= 1) AND ("length"("session_id") <= 255)) AND ("session_id" ~* '^(cs_|pi_)[a-zA-Z0-9_]+$'::"text"))),
    CONSTRAINT "payment_transactions_status_check" CHECK (("status" = ANY (ARRAY['completed'::"text", 'refunded'::"text", 'disputed'::"text"]))),
    CONSTRAINT "payment_transactions_stripe_payment_intent_id_check" CHECK ((("stripe_payment_intent_id" IS NULL) OR ((("length"("stripe_payment_intent_id") >= 1) AND ("length"("stripe_payment_intent_id") <= 255)) AND ("stripe_payment_intent_id" ~* '^pi_[a-zA-Z0-9_]+$'::"text")))),
    CONSTRAINT "valid_refund_amount" CHECK (("refunded_amount" <= "amount"))
);

ALTER TABLE ONLY "public"."payment_transactions" REPLICA IDENTITY FULL;


ALTER TABLE "public"."payment_transactions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."payment_system_health" WITH ("security_invoker"='on') AS
 SELECT 'payment_transactions'::"text" AS "table_name",
    "count"(*) AS "total_records",
    "count"(*) FILTER (WHERE ("status" = 'completed'::"text")) AS "completed_transactions",
    "count"(*) FILTER (WHERE ("status" = 'refunded'::"text")) AS "refunded_transactions",
    "count"(*) FILTER (WHERE ("status" = 'disputed'::"text")) AS "disputed_transactions",
    "avg"("amount") AS "avg_transaction_amount",
    "count"(*) FILTER (WHERE ("created_at" > ("now"() - '24:00:00'::interval))) AS "records_last_24h",
    "now"() AS "snapshot_time"
   FROM "public"."payment_transactions";


ALTER VIEW "public"."payment_system_health" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_categories" (
    "product_id" "uuid" NOT NULL,
    "category_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."product_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_price_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid" NOT NULL,
    "price" numeric NOT NULL,
    "sale_price" numeric,
    "currency" "text" NOT NULL,
    "vat_rate" numeric(5,2),
    "price_includes_vat" boolean DEFAULT true,
    "effective_from" timestamp with time zone DEFAULT "now"() NOT NULL,
    "effective_until" timestamp with time zone,
    "changed_by" "uuid",
    "change_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "product_price_history_currency_check" CHECK (("length"("currency") = 3)),
    CONSTRAINT "product_price_history_price_check" CHECK (("price" >= (0)::numeric)),
    CONSTRAINT "product_price_history_sale_price_check" CHECK (("sale_price" >= (0)::numeric))
);


ALTER TABLE "public"."product_price_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."product_price_history" IS 'Price history for Omnibus Directive compliance (EU 2019/2161) - tracks lowest price in last 30 days';



CREATE TABLE IF NOT EXISTS "public"."product_tags" (
    "product_id" "uuid" NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."product_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_variant_groups" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid" NOT NULL,
    "group_id" "uuid" NOT NULL,
    "variant_name" character varying(100),
    "display_order" integer DEFAULT 0 NOT NULL,
    "is_featured" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."product_variant_groups" OWNER TO "postgres";


COMMENT ON TABLE "public"."product_variant_groups" IS 'Junction table linking products to variant groups with display metadata';



COMMENT ON COLUMN "public"."product_variant_groups"."variant_name" IS 'Display name for this product in the variant selector';



COMMENT ON COLUMN "public"."product_variant_groups"."display_order" IS 'Order in variant selector (lower numbers appear first)';



COMMENT ON COLUMN "public"."product_variant_groups"."is_featured" IS 'Whether this product is the featured/highlighted option in the group';



CREATE TABLE IF NOT EXISTS "public"."products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text",
    "long_description" "text",
    "icon" "text",
    "image_url" "text",
    "thumbnail_url" "text",
    "price" numeric DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "vat_rate" numeric(5,2) DEFAULT 23.00,
    "price_includes_vat" boolean DEFAULT true NOT NULL,
    "features" "jsonb" DEFAULT '[]'::"jsonb",
    "layout_template" "text" DEFAULT 'default'::"text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "is_featured" boolean DEFAULT false NOT NULL,
    "available_from" timestamp with time zone,
    "available_until" timestamp with time zone,
    "auto_grant_duration_days" integer,
    "content_delivery_type" "text" DEFAULT 'content'::"text" NOT NULL,
    "content_config" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "tenant_id" "text",
    "success_redirect_url" "text",
    "pass_params_to_redirect" boolean DEFAULT false NOT NULL,
    "is_refundable" boolean DEFAULT false NOT NULL,
    "refund_period_days" integer,
    "enable_waitlist" boolean DEFAULT false NOT NULL,
    "allow_custom_price" boolean DEFAULT false NOT NULL,
    "custom_price_min" numeric(10,2) DEFAULT 5.00,
    "show_price_presets" boolean DEFAULT true NOT NULL,
    "custom_price_presets" "jsonb" DEFAULT '[5, 10, 25]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "omnibus_exempt" boolean DEFAULT false NOT NULL,
    "sale_price" numeric,
    "sale_price_until" timestamp with time zone,
    "sale_quantity_limit" integer,
    "sale_quantity_sold" integer DEFAULT 0 NOT NULL,
    CONSTRAINT "check_availability_dates" CHECK ((("available_from" IS NULL) OR ("available_until" IS NULL) OR ("available_from" < "available_until"))),
    CONSTRAINT "products_auto_grant_duration_days_check" CHECK ((("auto_grant_duration_days" > 0) AND ("auto_grant_duration_days" <= 3650))),
    CONSTRAINT "products_content_delivery_type_check" CHECK (("content_delivery_type" = ANY (ARRAY['redirect'::"text", 'content'::"text"]))),
    CONSTRAINT "products_currency_check" CHECK ((("length"("currency") = 3) AND ("upper"("currency") ~ '^[A-Z]{3}$'::"text") AND ("upper"("currency") = ANY (ARRAY['USD'::"text", 'EUR'::"text", 'GBP'::"text", 'CAD'::"text", 'AUD'::"text", 'JPY'::"text", 'CHF'::"text", 'CNY'::"text", 'SEK'::"text", 'NOK'::"text", 'DKK'::"text", 'PLN'::"text", 'CZK'::"text", 'HUF'::"text", 'RON'::"text", 'BGN'::"text", 'HRK'::"text", 'RUB'::"text", 'TRY'::"text", 'BRL'::"text", 'MXN'::"text", 'INR'::"text", 'KRW'::"text", 'SGD'::"text", 'HKD'::"text", 'NZD'::"text", 'ZAR'::"text", 'ILS'::"text", 'THB'::"text", 'MYR'::"text", 'PHP'::"text", 'IDR'::"text", 'VND'::"text"])))),
    CONSTRAINT "products_custom_price_min_check" CHECK (("custom_price_min" >= 0.50)),
    CONSTRAINT "products_description_check" CHECK (("length"("description") <= 2000)),
    CONSTRAINT "products_icon_check" CHECK (("length"("icon") <= 500)),
    CONSTRAINT "products_layout_template_check" CHECK (("length"("layout_template") <= 100)),
    CONSTRAINT "products_name_check" CHECK (("length"("name") <= 255)),
    CONSTRAINT "products_price_check" CHECK (("price" >= (0)::numeric)),
    CONSTRAINT "products_refund_period_days_check" CHECK ((("refund_period_days" IS NULL) OR (("refund_period_days" > 0) AND ("refund_period_days" <= 365)))),
    CONSTRAINT "products_sale_price_check" CHECK (("sale_price" >= (0)::numeric)),
    CONSTRAINT "products_sale_quantity_limit_check" CHECK ((("sale_quantity_limit" IS NULL) OR ("sale_quantity_limit" > 0))),
    CONSTRAINT "products_sale_quantity_sold_check" CHECK (("sale_quantity_sold" >= 0)),
    CONSTRAINT "products_slug_check" CHECK ((("slug" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("slug") >= 1) AND ("length"("slug") <= 100)))),
    CONSTRAINT "products_tenant_id_check" CHECK ((("tenant_id" IS NULL) OR (("tenant_id" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("tenant_id") >= 1) AND ("length"("tenant_id") <= 50)))))
);


ALTER TABLE "public"."products" OWNER TO "postgres";


COMMENT ON TABLE "public"."products" IS 'Products catalog with gatekeeper integration support';



COMMENT ON COLUMN "public"."products"."slug" IS 'URL-safe unique identifier for gatekeeper system';



COMMENT ON COLUMN "public"."products"."content_config" IS 'JSON configuration for content delivery and gatekeeper integration';



COMMENT ON COLUMN "public"."products"."tenant_id" IS 'Multi-tenant support - allows product isolation by tenant';



COMMENT ON COLUMN "public"."products"."omnibus_exempt" IS 'Exempt this product from Omnibus price history display (e.g., perishable goods, new arrivals <30 days)';



COMMENT ON COLUMN "public"."products"."sale_price" IS 'Promotional price for the product. When set and active (not expired), this is the public discounted price that triggers Omnibus display.';



COMMENT ON COLUMN "public"."products"."sale_price_until" IS 'Optional expiration date for sale_price. NULL means sale price is active indefinitely. When date passes, sale_price is no longer used.';



COMMENT ON COLUMN "public"."products"."sale_quantity_limit" IS 'Maximum number of units that can be sold at sale price (NULL = unlimited). When limit is reached, sale_price is no longer used.';



COMMENT ON COLUMN "public"."products"."sale_quantity_sold" IS 'Number of units already sold at sale price. Automatically incremented on successful payment when sale is active.';



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "first_name" "text",
    "last_name" "text",
    "full_name" "text",
    "display_name" "text",
    "avatar_url" "text",
    "company_name" "text",
    "tax_id" "text",
    "address_line1" "text",
    "address_line2" "text",
    "city" "text",
    "state" "text",
    "zip_code" "text",
    "country" "text",
    "preferred_language" "text" DEFAULT 'en'::"text",
    "timezone" "text" DEFAULT 'UTC'::"text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."rate_limits" (
    "user_id" "uuid" NOT NULL,
    "function_name" "text" NOT NULL,
    "window_start" timestamp with time zone NOT NULL,
    "call_count" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "rate_limits_call_count_check" CHECK (("call_count" > 0)),
    CONSTRAINT "rate_limits_function_name_check" CHECK (("length"("function_name") <= 100))
);


ALTER TABLE "public"."rate_limits" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."rate_limit_summary" WITH ("security_invoker"='on') AS
 SELECT "function_name",
    "count"(*) AS "total_calls",
    "count"(DISTINCT "user_id") AS "unique_users",
    "max"("updated_at") AS "last_activity",
    "max"("call_count") AS "max_calls_per_user",
    "avg"("call_count") AS "avg_calls_per_user"
   FROM "public"."rate_limits"
  GROUP BY "function_name";


ALTER VIEW "public"."rate_limit_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."refund_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transaction_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "customer_email" "text" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "reason" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "requested_amount" numeric NOT NULL,
    "currency" "text" NOT NULL,
    "admin_id" "uuid",
    "admin_response" "text",
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "refund_requests_admin_response_check" CHECK ((("admin_response" IS NULL) OR ("length"("admin_response") <= 2000))),
    CONSTRAINT "refund_requests_currency_check" CHECK (("length"("currency") = 3)),
    CONSTRAINT "refund_requests_customer_email_check" CHECK ("public"."validate_email_format"("customer_email")),
    CONSTRAINT "refund_requests_reason_check" CHECK ((("reason" IS NULL) OR ("length"("reason") <= 2000))),
    CONSTRAINT "refund_requests_requested_amount_check" CHECK (("requested_amount" > (0)::numeric)),
    CONSTRAINT "refund_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."refund_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."refund_requests" IS 'Customer-initiated refund requests that require admin approval';



CREATE TABLE IF NOT EXISTS "public"."revenue_goals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid",
    "goal_amount" bigint NOT NULL,
    "start_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."revenue_goals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shop_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shop_name" "text" DEFAULT 'My Shop'::"text" NOT NULL,
    "contact_email" "text",
    "default_currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "tax_rate" numeric(5,2) DEFAULT 0,
    "logo_url" "text",
    "primary_color" "text" DEFAULT '#9333ea'::"text",
    "secondary_color" "text" DEFAULT '#ec4899'::"text",
    "accent_color" "text" DEFAULT '#8b5cf6'::"text",
    "font_family" "text" DEFAULT 'system'::"text",
    "terms_of_service_url" "text",
    "privacy_policy_url" "text",
    "custom_settings" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "omnibus_enabled" boolean DEFAULT true NOT NULL,
    CONSTRAINT "shop_config_font_family_check" CHECK (("font_family" = ANY (ARRAY['system'::"text", 'inter'::"text", 'roboto'::"text", 'montserrat'::"text", 'poppins'::"text", 'playfair'::"text"])))
);


ALTER TABLE "public"."shop_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."shop_config" IS 'Global shop configuration settings (singleton)';



COMMENT ON COLUMN "public"."shop_config"."terms_of_service_url" IS 'URL to Terms of Service document (PDF, webpage, etc.)';



COMMENT ON COLUMN "public"."shop_config"."privacy_policy_url" IS 'URL to Privacy Policy document (PDF, webpage, etc.)';



COMMENT ON COLUMN "public"."shop_config"."custom_settings" IS 'Flexible JSONB field for additional custom settings';



COMMENT ON COLUMN "public"."shop_config"."omnibus_enabled" IS 'Global toggle for EU Omnibus Directive (2019/2161) price history display';



CREATE TABLE IF NOT EXISTS "public"."stripe_configurations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "mode" "text" NOT NULL,
    "encrypted_key" "text" NOT NULL,
    "encryption_iv" "text" NOT NULL,
    "encryption_tag" "text" NOT NULL,
    "key_last_4" "text" NOT NULL,
    "key_prefix" "text" NOT NULL,
    "permissions_verified" boolean DEFAULT false NOT NULL,
    "last_validated_at" timestamp with time zone,
    "account_id" "text",
    "expires_at" timestamp with time zone,
    "rotation_reminder_sent" boolean DEFAULT false,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "stripe_configurations_key_last_4_check" CHECK (("length"("key_last_4") = 4)),
    CONSTRAINT "stripe_configurations_key_prefix_check" CHECK (("key_prefix" = ANY (ARRAY['rk_test_'::"text", 'rk_live_'::"text", 'sk_test_'::"text", 'sk_live_'::"text"]))),
    CONSTRAINT "stripe_configurations_mode_check" CHECK (("mode" = ANY (ARRAY['test'::"text", 'live'::"text"])))
);


ALTER TABLE "public"."stripe_configurations" OWNER TO "postgres";


COMMENT ON TABLE "public"."stripe_configurations" IS 'Encrypted Stripe API keys with rotation support';



COMMENT ON COLUMN "public"."stripe_configurations"."encrypted_key" IS 'AES-256-GCM encrypted Stripe API key (base64 encoded)';



CREATE TABLE IF NOT EXISTS "public"."tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "tags_name_check" CHECK (("length"("name") <= 50)),
    CONSTRAINT "tags_slug_check" CHECK ((("slug" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("slug") >= 1) AND ("length"("slug") <= 50))))
);


ALTER TABLE "public"."tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_product_access" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "access_granted_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "access_expires_at" timestamp with time zone,
    "access_duration_days" integer,
    "tenant_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "version" integer DEFAULT 1 NOT NULL,
    CONSTRAINT "check_access_expiration" CHECK ((("access_expires_at" IS NULL) OR ("access_expires_at" > "access_granted_at"))),
    CONSTRAINT "user_product_access_access_duration_days_check" CHECK ((("access_duration_days" IS NULL) OR (("access_duration_days" > 0) AND ("access_duration_days" <= 3650)))),
    CONSTRAINT "user_product_access_tenant_id_check" CHECK ((("tenant_id" IS NULL) OR (("tenant_id" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("tenant_id") >= 1) AND ("length"("tenant_id") <= 50)))))
);


ALTER TABLE "public"."user_product_access" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."user_access_stats" WITH ("security_invoker"='on') AS
 SELECT "u"."id" AS "user_id",
    "u"."email",
    "u"."created_at" AS "user_created_at",
    "u"."email_confirmed_at",
    "u"."last_sign_in_at",
    "u"."raw_user_meta_data",
    "count"("upa"."id") AS "total_products",
    COALESCE("sum"("p"."price"), (0)::numeric) AS "total_value",
    "max"("upa"."created_at") AS "last_access_granted_at",
    "min"("upa"."created_at") AS "first_access_granted_at"
   FROM (("auth"."users" "u"
     LEFT JOIN "public"."user_product_access" "upa" ON (("u"."id" = "upa"."user_id")))
     LEFT JOIN "public"."products" "p" ON (("upa"."product_id" = "p"."id")))
  GROUP BY "u"."id", "u"."email", "u"."created_at", "u"."email_confirmed_at", "u"."last_sign_in_at", "u"."raw_user_meta_data";


ALTER VIEW "public"."user_access_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."user_product_access_detailed" WITH ("security_invoker"='on') AS
 SELECT "upa"."id",
    "upa"."user_id",
    "upa"."product_id",
    "p"."slug" AS "product_slug",
    "p"."name" AS "product_name",
    "p"."description" AS "product_description",
    "p"."price" AS "product_price",
    "p"."currency" AS "product_currency",
    "p"."icon" AS "product_icon",
    "p"."is_active" AS "product_is_active",
    "upa"."access_granted_at",
    "upa"."access_expires_at",
    "upa"."access_duration_days",
    "upa"."created_at" AS "access_created_at",
    "p"."created_at" AS "product_created_at",
    "p"."updated_at" AS "product_updated_at",
    "upa"."tenant_id"
   FROM ("public"."user_product_access" "upa"
     JOIN "public"."products" "p" ON (("upa"."product_id" = "p"."id")));


ALTER VIEW "public"."user_product_access_detailed" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."variant_groups" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text",
    "slug" "text",
    "tenant_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "variant_groups_name_check" CHECK (("length"("name") <= 200)),
    CONSTRAINT "variant_groups_slug_check" CHECK ((("slug" IS NULL) OR (("slug" ~ '^[a-z0-9_-]+$'::"text") AND (("length"("slug") >= 1) AND ("length"("slug") <= 100))))),
    CONSTRAINT "variant_groups_tenant_id_check" CHECK ((("tenant_id" IS NULL) OR (("tenant_id" ~ '^[a-zA-Z0-9_-]+$'::"text") AND (("length"("tenant_id") >= 1) AND ("length"("tenant_id") <= 50)))))
);


ALTER TABLE "public"."variant_groups" OWNER TO "postgres";


COMMENT ON TABLE "public"."variant_groups" IS 'Variant groups for organizing products as selectable options';



COMMENT ON COLUMN "public"."variant_groups"."name" IS 'Optional human-readable name for the variant group';



COMMENT ON COLUMN "public"."variant_groups"."slug" IS 'URL-friendly identifier for the variant group (alternative to UUID)';



CREATE TABLE IF NOT EXISTS "public"."video_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "progress_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "position_seconds" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "video_events_event_type_check" CHECK (("event_type" = ANY (ARRAY['play'::"text", 'pause'::"text", 'seek'::"text", 'heartbeat'::"text", 'complete'::"text"])))
);


ALTER TABLE "public"."video_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."video_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "video_id" "text" NOT NULL,
    "last_position_seconds" integer DEFAULT 0 NOT NULL,
    "max_position_seconds" integer DEFAULT 0 NOT NULL,
    "video_duration_seconds" integer,
    "is_completed" boolean DEFAULT false NOT NULL,
    "view_count" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."video_progress" OWNER TO "postgres";


COMMENT ON TABLE "public"."video_progress" IS 'Tracks user progress for video content';



CREATE TABLE IF NOT EXISTS "public"."webhook_endpoints" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "url" "text" NOT NULL,
    "events" "text"[] DEFAULT '{}'::"text"[] NOT NULL,
    "secret" "text" DEFAULT "replace"(("gen_random_uuid"())::"text", '-'::"text", ''::"text") NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."webhook_endpoints" OWNER TO "postgres";


COMMENT ON TABLE "public"."webhook_endpoints" IS 'Webhook endpoint configurations';



CREATE TABLE IF NOT EXISTS "public"."webhook_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "endpoint_id" "uuid",
    "event_type" "text" NOT NULL,
    "payload" "jsonb",
    "status" "text" NOT NULL,
    "http_status" integer,
    "response_body" "text",
    "error_message" "text",
    "duration_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "webhook_logs_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'failed'::"text", 'retried'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."webhook_logs" OWNER TO "postgres";


ALTER TABLE ONLY "public"."admin_actions"
    ADD CONSTRAINT "admin_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."api_key_audit_log"
    ADD CONSTRAINT "api_key_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."application_rate_limits"
    ADD CONSTRAINT "application_rate_limits_identifier_action_type_window_start_key" UNIQUE ("identifier", "action_type", "window_start");



ALTER TABLE ONLY "public"."application_rate_limits"
    ADD CONSTRAINT "application_rate_limits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."audit_log"
    ADD CONSTRAINT "audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."consent_logs"
    ADD CONSTRAINT "consent_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coupon_redemptions"
    ADD CONSTRAINT "coupon_redemptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coupon_reservations"
    ADD CONSTRAINT "coupon_reservations_coupon_id_customer_email_key" UNIQUE ("coupon_id", "customer_email");



ALTER TABLE ONLY "public"."coupon_reservations"
    ADD CONSTRAINT "coupon_reservations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."custom_scripts"
    ADD CONSTRAINT "custom_scripts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."guest_purchases"
    ADD CONSTRAINT "guest_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."guest_purchases"
    ADD CONSTRAINT "guest_purchases_session_id_key" UNIQUE ("session_id");



ALTER TABLE ONLY "public"."integrations_config"
    ADD CONSTRAINT "integrations_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_bumps"
    ADD CONSTRAINT "order_bumps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."oto_offers"
    ADD CONSTRAINT "oto_offers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_pkey" PRIMARY KEY ("product_id", "category_id");



ALTER TABLE ONLY "public"."product_price_history"
    ADD CONSTRAINT "product_price_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_tags"
    ADD CONSTRAINT "product_tags_pkey" PRIMARY KEY ("product_id", "tag_id");



ALTER TABLE ONLY "public"."product_variant_groups"
    ADD CONSTRAINT "product_variant_groups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_variant_groups"
    ADD CONSTRAINT "product_variant_groups_product_id_group_id_key" UNIQUE ("product_id", "group_id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."rate_limits"
    ADD CONSTRAINT "rate_limits_pkey" PRIMARY KEY ("user_id", "function_name", "window_start");



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "refund_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."revenue_goals"
    ADD CONSTRAINT "revenue_goals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shop_config"
    ADD CONSTRAINT "shop_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stripe_configurations"
    ADD CONSTRAINT "stripe_configurations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tags"
    ADD CONSTRAINT "tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tags"
    ADD CONSTRAINT "tags_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."order_bumps"
    ADD CONSTRAINT "unique_bump_pair" UNIQUE ("main_product_id", "bump_product_id");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "unique_coupon_code" UNIQUE ("code");



ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "unique_key_hash" UNIQUE ("key_hash");



ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "unique_key_prefix" UNIQUE ("key_prefix");



ALTER TABLE ONLY "public"."oto_offers"
    ADD CONSTRAINT "unique_oto_pair" UNIQUE ("source_product_id", "oto_product_id");



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "unique_pending_request" UNIQUE ("transaction_id") DEFERRABLE INITIALLY DEFERRED;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "unique_session_id" UNIQUE ("session_id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "unique_stripe_payment_intent_id" UNIQUE ("stripe_payment_intent_id") DEFERRABLE INITIALLY DEFERRED;



ALTER TABLE ONLY "public"."video_progress"
    ADD CONSTRAINT "unique_user_video_progress" UNIQUE ("user_id", "product_id", "video_id");



ALTER TABLE ONLY "public"."user_product_access"
    ADD CONSTRAINT "user_product_access_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_product_access"
    ADD CONSTRAINT "user_product_access_user_id_product_id_key" UNIQUE ("user_id", "product_id");



ALTER TABLE ONLY "public"."variant_groups"
    ADD CONSTRAINT "variant_groups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."variant_groups"
    ADD CONSTRAINT "variant_groups_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."video_events"
    ADD CONSTRAINT "video_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."video_progress"
    ADD CONSTRAINT "video_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."webhook_endpoints"
    ADD CONSTRAINT "webhook_endpoints_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."webhook_logs"
    ADD CONSTRAINT "webhook_logs_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_admin_actions_admin_id" ON "public"."admin_actions" USING "btree" ("admin_id");



CREATE INDEX "idx_admin_actions_created_at" ON "public"."admin_actions" USING "brin" ("created_at");



CREATE INDEX "idx_admin_actions_target" ON "public"."admin_actions" USING "btree" ("target_type", "target_id");



CREATE INDEX "idx_admin_users_user_id" ON "public"."admin_users" USING "btree" ("user_id");



CREATE INDEX "idx_api_key_audit_log_created_at" ON "public"."api_key_audit_log" USING "btree" ("created_at");



CREATE INDEX "idx_api_key_audit_log_key_id" ON "public"."api_key_audit_log" USING "btree" ("api_key_id");



CREATE INDEX "idx_api_keys_admin_user_id" ON "public"."api_keys" USING "btree" ("admin_user_id");



CREATE INDEX "idx_api_keys_is_active" ON "public"."api_keys" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_api_keys_key_hash" ON "public"."api_keys" USING "btree" ("key_hash");



CREATE INDEX "idx_application_rate_limits_lookup" ON "public"."application_rate_limits" USING "btree" ("identifier", "action_type", "window_start" DESC);



CREATE INDEX "idx_application_rate_limits_window_start" ON "public"."application_rate_limits" USING "btree" ("window_start");



CREATE INDEX "idx_audit_log_performed_at" ON "public"."audit_log" USING "btree" ("performed_at" DESC);



CREATE INDEX "idx_categories_parent_id" ON "public"."categories" USING "btree" ("parent_id");



CREATE INDEX "idx_categories_slug" ON "public"."categories" USING "btree" ("slug");



CREATE INDEX "idx_coupon_redemptions_email" ON "public"."coupon_redemptions" USING "btree" ("customer_email");



CREATE INDEX "idx_coupon_redemptions_user" ON "public"."coupon_redemptions" USING "btree" ("user_id");



CREATE INDEX "idx_coupon_reservations_coupon" ON "public"."coupon_reservations" USING "btree" ("coupon_id");



CREATE INDEX "idx_coupon_reservations_email" ON "public"."coupon_reservations" USING "btree" ("customer_email");



CREATE INDEX "idx_coupon_reservations_expires" ON "public"."coupon_reservations" USING "btree" ("expires_at");



CREATE INDEX "idx_coupons_active" ON "public"."coupons" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_coupons_code" ON "public"."coupons" USING "btree" ("code");



CREATE INDEX "idx_coupons_oto" ON "public"."coupons" USING "btree" ("is_oto_coupon") WHERE ("is_oto_coupon" = true);



CREATE INDEX "idx_coupons_oto_expires" ON "public"."coupons" USING "btree" ("expires_at") WHERE ("is_oto_coupon" = true);



CREATE UNIQUE INDEX "idx_coupons_oto_transaction_unique" ON "public"."coupons" USING "btree" ("source_transaction_id") WHERE (("source_transaction_id" IS NOT NULL) AND ("is_oto_coupon" = true));



CREATE INDEX "idx_coupons_source_transaction" ON "public"."coupons" USING "btree" ("source_transaction_id") WHERE ("source_transaction_id" IS NOT NULL);



CREATE INDEX "idx_guest_purchases_claimed_by_user_id" ON "public"."guest_purchases" USING "btree" ("claimed_by_user_id") WHERE ("claimed_by_user_id" IS NOT NULL);



CREATE INDEX "idx_guest_purchases_cleanup" ON "public"."guest_purchases" USING "brin" ("created_at");



CREATE INDEX "idx_guest_purchases_customer_email" ON "public"."guest_purchases" USING "btree" ("customer_email");



CREATE INDEX "idx_guest_purchases_metadata" ON "public"."guest_purchases" USING "gin" ("metadata");



CREATE INDEX "idx_guest_purchases_product_id" ON "public"."guest_purchases" USING "btree" ("product_id");



CREATE INDEX "idx_guest_purchases_session_id" ON "public"."guest_purchases" USING "btree" ("session_id");



CREATE INDEX "idx_integrations_config_currency_api_enabled" ON "public"."integrations_config" USING "btree" ("currency_api_enabled") WHERE ("currency_api_enabled" = true);



CREATE INDEX "idx_integrations_config_gus_enabled" ON "public"."integrations_config" USING "btree" ("gus_api_enabled") WHERE ("gus_api_enabled" = true);



CREATE INDEX "idx_order_bumps_bump_product" ON "public"."order_bumps" USING "btree" ("bump_product_id");



CREATE INDEX "idx_order_bumps_created_at" ON "public"."order_bumps" USING "brin" ("created_at");



CREATE INDEX "idx_order_bumps_main_product" ON "public"."order_bumps" USING "btree" ("main_product_id", "is_active", "display_order");



CREATE INDEX "idx_oto_offers_oto_product" ON "public"."oto_offers" USING "btree" ("oto_product_id");



CREATE INDEX "idx_oto_offers_source_product" ON "public"."oto_offers" USING "btree" ("source_product_id", "is_active", "display_order");



CREATE INDEX "idx_payment_transactions_created_at" ON "public"."payment_transactions" USING "brin" ("created_at");



CREATE INDEX "idx_payment_transactions_customer_email" ON "public"."payment_transactions" USING "btree" ("customer_email");



CREATE INDEX "idx_payment_transactions_email_date" ON "public"."payment_transactions" USING "btree" ("customer_email", "created_at" DESC);



CREATE INDEX "idx_payment_transactions_product_id" ON "public"."payment_transactions" USING "btree" ("product_id");



CREATE INDEX "idx_payment_transactions_status_date" ON "public"."payment_transactions" USING "btree" ("status", "created_at" DESC) WHERE ("status" = ANY (ARRAY['refunded'::"text", 'disputed'::"text"]));



CREATE INDEX "idx_payment_transactions_user_id" ON "public"."payment_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_product_categories_category_id" ON "public"."product_categories" USING "btree" ("category_id");



CREATE INDEX "idx_product_categories_product_id" ON "public"."product_categories" USING "btree" ("product_id");



CREATE INDEX "idx_product_price_history_current" ON "public"."product_price_history" USING "btree" ("product_id", "effective_until") WHERE ("effective_until" IS NULL);



CREATE INDEX "idx_product_price_history_product_date" ON "public"."product_price_history" USING "btree" ("product_id", "effective_from" DESC);



CREATE INDEX "idx_product_tags_product_id" ON "public"."product_tags" USING "btree" ("product_id");



CREATE INDEX "idx_product_tags_tag_id" ON "public"."product_tags" USING "btree" ("tag_id");



CREATE INDEX "idx_product_variant_groups_display_order" ON "public"."product_variant_groups" USING "btree" ("group_id", "display_order");



CREATE INDEX "idx_product_variant_groups_featured" ON "public"."product_variant_groups" USING "btree" ("group_id", "is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_product_variant_groups_group_id" ON "public"."product_variant_groups" USING "btree" ("group_id");



CREATE INDEX "idx_product_variant_groups_product_id" ON "public"."product_variant_groups" USING "btree" ("product_id");



CREATE INDEX "idx_products_created_at" ON "public"."products" USING "btree" ("created_at");



CREATE INDEX "idx_products_is_active" ON "public"."products" USING "btree" ("is_active");



CREATE INDEX "idx_products_is_featured" ON "public"."products" USING "btree" ("is_featured");



CREATE INDEX "idx_products_is_refundable" ON "public"."products" USING "btree" ("is_refundable") WHERE ("is_refundable" = true);



CREATE INDEX "idx_products_price" ON "public"."products" USING "btree" ("price");



CREATE INDEX "idx_products_slug" ON "public"."products" USING "btree" ("slug");



CREATE INDEX "idx_products_tenant_id" ON "public"."products" USING "btree" ("tenant_id") WHERE ("tenant_id" IS NOT NULL);



CREATE INDEX "idx_rate_limits_cleanup_brin" ON "public"."rate_limits" USING "brin" ("window_start");



CREATE INDEX "idx_rate_limits_user_function" ON "public"."rate_limits" USING "btree" ("user_id", "function_name");



CREATE INDEX "idx_rate_limits_window_start" ON "public"."rate_limits" USING "btree" ("window_start");



CREATE INDEX "idx_refund_requests_created_at" ON "public"."refund_requests" USING "brin" ("created_at");



CREATE INDEX "idx_refund_requests_status" ON "public"."refund_requests" USING "btree" ("status");



CREATE INDEX "idx_refund_requests_transaction_id" ON "public"."refund_requests" USING "btree" ("transaction_id");



CREATE INDEX "idx_refund_requests_user_id" ON "public"."refund_requests" USING "btree" ("user_id");



CREATE INDEX "idx_stripe_config_active" ON "public"."stripe_configurations" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_stripe_config_expires_at" ON "public"."stripe_configurations" USING "btree" ("expires_at") WHERE (("is_active" = true) AND ("expires_at" IS NOT NULL));



CREATE INDEX "idx_stripe_config_mode" ON "public"."stripe_configurations" USING "btree" ("mode");



CREATE INDEX "idx_tags_slug" ON "public"."tags" USING "btree" ("slug");



CREATE INDEX "idx_user_product_access_expires_at" ON "public"."user_product_access" USING "btree" ("access_expires_at") WHERE ("access_expires_at" IS NOT NULL);



CREATE INDEX "idx_user_product_access_product_id" ON "public"."user_product_access" USING "btree" ("product_id");



CREATE INDEX "idx_user_product_access_tenant_id" ON "public"."user_product_access" USING "btree" ("tenant_id") WHERE ("tenant_id" IS NOT NULL);



CREATE INDEX "idx_user_product_access_unique" ON "public"."user_product_access" USING "btree" ("user_id", "product_id");



CREATE INDEX "idx_user_product_access_user_id" ON "public"."user_product_access" USING "btree" ("user_id");



CREATE INDEX "idx_user_product_access_version" ON "public"."user_product_access" USING "btree" ("user_id", "product_id", "version");



CREATE INDEX "idx_variant_groups_tenant_id" ON "public"."variant_groups" USING "btree" ("tenant_id") WHERE ("tenant_id" IS NOT NULL);



CREATE INDEX "idx_video_events_progress" ON "public"."video_events" USING "btree" ("progress_id");



CREATE INDEX "idx_video_progress_product" ON "public"."video_progress" USING "btree" ("product_id");



CREATE INDEX "idx_video_progress_user" ON "public"."video_progress" USING "btree" ("user_id");



CREATE INDEX "idx_webhook_logs_created_at" ON "public"."webhook_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_webhook_logs_endpoint_id" ON "public"."webhook_logs" USING "btree" ("endpoint_id");



CREATE INDEX "idx_webhook_logs_status" ON "public"."webhook_logs" USING "btree" ("status");



CREATE UNIQUE INDEX "revenue_goals_global_idx" ON "public"."revenue_goals" USING "btree" ((1)) WHERE ("product_id" IS NULL);



CREATE UNIQUE INDEX "revenue_goals_product_idx" ON "public"."revenue_goals" USING "btree" ("product_id") WHERE ("product_id" IS NOT NULL);



CREATE UNIQUE INDEX "shop_config_singleton_idx" ON "public"."shop_config" USING "btree" ((true));



CREATE UNIQUE INDEX "unique_active_mode_per_stripe_config" ON "public"."stripe_configurations" USING "btree" ("mode", "is_active") WHERE ("is_active" = true);



CREATE OR REPLACE TRIGGER "audit_admin_users" AFTER INSERT OR DELETE OR UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();



CREATE OR REPLACE TRIGGER "audit_guest_purchases_updates" AFTER UPDATE ON "public"."guest_purchases" FOR EACH ROW EXECUTE FUNCTION "public"."log_admin_action_trigger"();



CREATE OR REPLACE TRIGGER "audit_payment_transactions" AFTER INSERT OR DELETE OR UPDATE ON "public"."payment_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."log_admin_action_trigger"();



CREATE OR REPLACE TRIGGER "audit_user_product_access" AFTER INSERT OR DELETE OR UPDATE ON "public"."user_product_access" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();



CREATE OR REPLACE TRIGGER "cleanup_price_history_trigger" AFTER INSERT ON "public"."product_price_history" FOR EACH STATEMENT EXECUTE FUNCTION "public"."cleanup_old_price_history"();



CREATE OR REPLACE TRIGGER "logs_monitoring_trigger" AFTER INSERT ON "public"."admin_actions" FOR EACH ROW EXECUTE FUNCTION "public"."logs_monitoring_trigger"();



CREATE OR REPLACE TRIGGER "product_price_change_trigger" AFTER INSERT OR UPDATE OF "price", "sale_price", "currency", "vat_rate" ON "public"."products" FOR EACH ROW EXECUTE FUNCTION "public"."log_product_price_change"();



CREATE OR REPLACE TRIGGER "trigger_update_coupons_updated_at" BEFORE UPDATE ON "public"."coupons" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_custom_scripts_updated_at" BEFORE UPDATE ON "public"."custom_scripts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_integrations_config_updated_at" BEFORE UPDATE ON "public"."integrations_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_order_bumps_updated_at" BEFORE UPDATE ON "public"."order_bumps" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_oto_offers_updated_at" BEFORE UPDATE ON "public"."oto_offers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_refund_request_timestamp" BEFORE UPDATE ON "public"."refund_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_refund_request_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_update_refunded_at" BEFORE UPDATE ON "public"."payment_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_refunded_at"();



CREATE OR REPLACE TRIGGER "trigger_update_revenue_goals_updated_at" BEFORE UPDATE ON "public"."revenue_goals" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_shop_config_updated_at" BEFORE UPDATE ON "public"."shop_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_stripe_configurations_updated_at" BEFORE UPDATE ON "public"."stripe_configurations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_video_progress_updated_at" BEFORE UPDATE ON "public"."video_progress" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_webhook_endpoints_updated_at" BEFORE UPDATE ON "public"."webhook_endpoints" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_categories_updated_at" BEFORE UPDATE ON "public"."categories" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_products_updated_at" BEFORE UPDATE ON "public"."products" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_variant_groups_updated_at" BEFORE UPDATE ON "public"."variant_groups" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."admin_actions"
    ADD CONSTRAINT "admin_actions_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."api_key_audit_log"
    ADD CONSTRAINT "api_key_audit_log_api_key_id_fkey" FOREIGN KEY ("api_key_id") REFERENCES "public"."api_keys"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "public"."admin_users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_rotated_from_id_fkey" FOREIGN KEY ("rotated_from_id") REFERENCES "public"."api_keys"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."audit_log"
    ADD CONSTRAINT "audit_log_performed_by_fkey" FOREIGN KEY ("performed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."audit_log"
    ADD CONSTRAINT "audit_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."categories"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."coupon_redemptions"
    ADD CONSTRAINT "coupon_redemptions_coupon_id_fkey" FOREIGN KEY ("coupon_id") REFERENCES "public"."coupons"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."coupon_redemptions"
    ADD CONSTRAINT "coupon_redemptions_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."payment_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."coupon_redemptions"
    ADD CONSTRAINT "coupon_redemptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."coupon_reservations"
    ADD CONSTRAINT "coupon_reservations_coupon_id_fkey" FOREIGN KEY ("coupon_id") REFERENCES "public"."coupons"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_oto_offer_id_fkey" FOREIGN KEY ("oto_offer_id") REFERENCES "public"."oto_offers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_source_transaction_id_fkey" FOREIGN KEY ("source_transaction_id") REFERENCES "public"."payment_transactions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."guest_purchases"
    ADD CONSTRAINT "guest_purchases_claimed_by_user_id_fkey" FOREIGN KEY ("claimed_by_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."guest_purchases"
    ADD CONSTRAINT "guest_purchases_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_bumps"
    ADD CONSTRAINT "order_bumps_bump_product_id_fkey" FOREIGN KEY ("bump_product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_bumps"
    ADD CONSTRAINT "order_bumps_main_product_id_fkey" FOREIGN KEY ("main_product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oto_offers"
    ADD CONSTRAINT "oto_offers_oto_product_id_fkey" FOREIGN KEY ("oto_product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oto_offers"
    ADD CONSTRAINT "oto_offers_source_product_id_fkey" FOREIGN KEY ("source_product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_refunded_by_fkey" FOREIGN KEY ("refunded_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_price_history"
    ADD CONSTRAINT "product_price_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."product_price_history"
    ADD CONSTRAINT "product_price_history_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_tags"
    ADD CONSTRAINT "product_tags_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_tags"
    ADD CONSTRAINT "product_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_variant_groups"
    ADD CONSTRAINT "product_variant_groups_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."variant_groups"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_variant_groups"
    ADD CONSTRAINT "product_variant_groups_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "refund_requests_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "refund_requests_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "refund_requests_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."payment_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."refund_requests"
    ADD CONSTRAINT "refund_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."revenue_goals"
    ADD CONSTRAINT "revenue_goals_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_product_access"
    ADD CONSTRAINT "user_product_access_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_product_access"
    ADD CONSTRAINT "user_product_access_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."video_events"
    ADD CONSTRAINT "video_events_progress_id_fkey" FOREIGN KEY ("progress_id") REFERENCES "public"."video_progress"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."video_progress"
    ADD CONSTRAINT "video_progress_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."video_progress"
    ADD CONSTRAINT "video_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_logs"
    ADD CONSTRAINT "webhook_logs_endpoint_id_fkey" FOREIGN KEY ("endpoint_id") REFERENCES "public"."webhook_endpoints"("id") ON DELETE CASCADE;



CREATE POLICY "Admin users can delete their own API keys" ON "public"."api_keys" FOR DELETE TO "authenticated" USING (("admin_user_id" IN ( SELECT "admin_users"."id"
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admin users can insert their own API keys" ON "public"."api_keys" FOR INSERT TO "authenticated" WITH CHECK (("admin_user_id" IN ( SELECT "admin_users"."id"
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admin users can update their own API keys" ON "public"."api_keys" FOR UPDATE TO "authenticated" USING (("admin_user_id" IN ( SELECT "admin_users"."id"
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admin users can view audit logs for their own keys" ON "public"."api_key_audit_log" FOR SELECT TO "authenticated" USING (("api_key_id" IN ( SELECT "ak"."id"
   FROM ("public"."api_keys" "ak"
     JOIN "public"."admin_users" "au" ON (("ak"."admin_user_id" = "au"."id")))
  WHERE ("au"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admin users can view their own API keys" ON "public"."api_keys" FOR SELECT TO "authenticated" USING (("admin_user_id" IN ( SELECT "admin_users"."id"
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admin view" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")));



CREATE POLICY "Admins can delete order bumps" ON "public"."order_bumps" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can insert admin actions" ON "public"."admin_actions" FOR INSERT WITH CHECK (((("admin_id" = ( SELECT "auth"."uid"() AS "uid")) AND (EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))) OR (( SELECT ( SELECT "auth"."role"() AS "role") AS "role") = 'service_role'::"text")));



CREATE POLICY "Admins can insert order bumps" ON "public"."order_bumps" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can manage oto_offers" ON "public"."oto_offers" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can manage revenue goals" ON "public"."revenue_goals" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can manage webhook endpoints" ON "public"."webhook_endpoints" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE ("au"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can update order bumps" ON "public"."order_bumps" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can update payment transactions for refunds" ON "public"."payment_transactions" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Admins can update refund requests" ON "public"."refund_requests" FOR UPDATE USING (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR (( SELECT "auth"."role"() AS "role") = 'service_role'::"text")));



CREATE POLICY "Admins can update webhook logs" ON "public"."webhook_logs" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE ("au"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can view admin actions" ON "public"."admin_actions" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Admins can view all video events" ON "public"."video_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can view all video progress" ON "public"."video_progress" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can view order bumps" ON "public"."order_bumps" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins can view webhook logs" ON "public"."webhook_logs" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE ("au"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access coupons" ON "public"."coupons" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for categories" ON "public"."categories" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for product_categories" ON "public"."product_categories" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for product_tags" ON "public"."product_tags" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for product_variant_groups" ON "public"."product_variant_groups" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for tags" ON "public"."tags" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access for variant_groups" ON "public"."variant_groups" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access redemptions" ON "public"."coupon_redemptions" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access reservations" ON "public"."coupon_reservations" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access to shop_config" ON "public"."shop_config" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Admins full access to stripe_configurations" ON "public"."stripe_configurations" USING (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text")))) WITH CHECK (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text"))));



CREATE POLICY "Admins manage config" ON "public"."integrations_config" USING ((("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text")))) WITH CHECK ((("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text"))));



CREATE POLICY "Admins manage scripts" ON "public"."custom_scripts" USING ((("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text")))) WITH CHECK ((("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text"))));



CREATE POLICY "Admins view logs" ON "public"."consent_logs" FOR SELECT USING ((("auth"."uid"() IN ( SELECT "admin_users"."user_id"
   FROM "public"."admin_users")) OR ( SELECT ("current_setting"('role'::"text", true) = 'service_role'::"text"))));



CREATE POLICY "Allow admin users to delete access" ON "public"."user_product_access" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow admin users to delete products" ON "public"."products" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow admin users to insert products" ON "public"."products" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow admin users to read audit logs" ON "public"."audit_log" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow admin users to update access" ON "public"."user_product_access" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow admin users to update products" ON "public"."products" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow service role to insert product access" ON "public"."user_product_access" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Allow system to delete rate limits" ON "public"."rate_limits" FOR DELETE TO "service_role" USING (true);



CREATE POLICY "Allow system to insert audit logs" ON "public"."audit_log" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Allow system to insert rate limits" ON "public"."rate_limits" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Allow system to update rate limits" ON "public"."rate_limits" FOR UPDATE TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow users to read their own admin status" ON "public"."admin_users" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to read their own product access" ON "public"."user_product_access" FOR SELECT USING (((( SELECT "auth"."uid"() AS "uid") = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Combined INSERT policy for user_product_access" ON "public"."user_product_access" FOR INSERT TO "authenticated" WITH CHECK (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR ((( SELECT "auth"."uid"() AS "uid") = "user_id") AND (EXISTS ( SELECT 1
   FROM "public"."products"
  WHERE (("products"."id" = "user_product_access"."product_id") AND ("products"."price" = (0)::numeric)))))));



CREATE POLICY "Combined SELECT policy for guest purchases" ON "public"."guest_purchases" FOR SELECT USING ((("claimed_by_user_id" = ( SELECT "auth"."uid"() AS "uid")) OR (( SELECT "auth"."role"() AS "role") = 'service_role'::"text")));



CREATE POLICY "Combined SELECT policy for payment transactions" ON "public"."payment_transactions" FOR SELECT USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR (( SELECT "auth"."role"() AS "role") = 'service_role'::"text")));



CREATE POLICY "Combined SELECT policy for rate limits" ON "public"."rate_limits" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Only admins can delete price history" ON "public"."product_price_history" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Only admins can update price history" ON "public"."product_price_history" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Only system or admins can insert price history" ON "public"."product_price_history" FOR INSERT WITH CHECK ((("auth"."uid"() IS NULL) OR (EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = "auth"."uid"())))));



CREATE POLICY "Price history is publicly readable" ON "public"."product_price_history" FOR SELECT USING (true);



CREATE POLICY "Public can view active order bumps" ON "public"."order_bumps" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public can view active oto_offers" ON "public"."oto_offers" FOR SELECT TO "authenticated", "anon" USING (("is_active" = true));



CREATE POLICY "Public log consent" ON "public"."consent_logs" FOR INSERT WITH CHECK (true);



CREATE POLICY "Public read access for categories" ON "public"."categories" FOR SELECT USING (true);



CREATE POLICY "Public read access for product_categories" ON "public"."product_categories" FOR SELECT USING (true);



CREATE POLICY "Public read access for product_tags" ON "public"."product_tags" FOR SELECT USING (true);



CREATE POLICY "Public read access for product_variant_groups" ON "public"."product_variant_groups" FOR SELECT USING (true);



CREATE POLICY "Public read access for tags" ON "public"."tags" FOR SELECT USING (true);



CREATE POLICY "Public read access for variant_groups" ON "public"."variant_groups" FOR SELECT USING (true);



CREATE POLICY "Public read access to shop_config" ON "public"."shop_config" FOR SELECT USING (true);



CREATE POLICY "SELECT policy for products" ON "public"."products" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR ("is_active" = true) OR (("is_active" = false) AND ("enable_waitlist" = true))));



CREATE POLICY "Self update" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id"));



CREATE POLICY "Self view" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "id"));



CREATE POLICY "Service role can delete guest purchases" ON "public"."guest_purchases" FOR DELETE TO "service_role" USING (true);



CREATE POLICY "Service role can insert guest purchases" ON "public"."guest_purchases" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Service role can manage order bumps" ON "public"."order_bumps" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role can update guest purchases" ON "public"."guest_purchases" FOR UPDATE TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access coupons" ON "public"."coupons" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access redemptions" ON "public"."coupon_redemptions" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access reservations" ON "public"."coupon_reservations" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to oto_offers" ON "public"."oto_offers" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role has full access to rate limits" ON "public"."application_rate_limits" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role limited access payment transactions" ON "public"."payment_transactions" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Users can create refund requests" ON "public"."refund_requests" FOR INSERT WITH CHECK ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) OR (( SELECT "auth"."role"() AS "role") = 'service_role'::"text")));



CREATE POLICY "Users can insert own video events" ON "public"."video_events" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."video_progress"
  WHERE (("video_progress"."id" = "video_events"."progress_id") AND ("video_progress"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can insert own video progress" ON "public"."video_progress" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own video progress" ON "public"."video_progress" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own refund requests" ON "public"."refund_requests" FOR SELECT USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("customer_email" = (( SELECT "users"."email"
   FROM "auth"."users"
  WHERE ("users"."id" = ( SELECT "auth"."uid"() AS "uid"))))::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE ("admin_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR (( SELECT "auth"."role"() AS "role") = 'service_role'::"text")));



CREATE POLICY "Users can view own video events" ON "public"."video_events" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."video_progress"
  WHERE (("video_progress"."id" = "video_events"."progress_id") AND ("video_progress"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view own video progress" ON "public"."video_progress" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users view own redemptions" ON "public"."coupon_redemptions" FOR SELECT USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."admin_actions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."api_key_audit_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."api_keys" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."application_rate_limits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."audit_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."consent_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coupon_redemptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coupon_reservations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coupons" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."custom_scripts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."guest_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."integrations_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."order_bumps" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."oto_offers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_price_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_tags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_variant_groups" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."rate_limits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."refund_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_goals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stripe_configurations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_product_access" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."variant_groups" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."video_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."video_progress" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_endpoints" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_logs" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payment_transactions";









GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";




















































































































































































GRANT ALL ON FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_delete_oto_offer"("source_product_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_get_product_order_bumps"("product_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_get_product_order_bumps"("product_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_get_product_order_bumps"("product_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_get_product_oto_offer"("product_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer, "is_active_param" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer, "is_active_param" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_save_oto_offer"("source_product_id_param" "uuid", "oto_product_id_param" "uuid", "discount_type_param" "text", "discount_value_param" numeric, "duration_minutes_param" integer, "is_active_param" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "anon";
GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "service_role";



GRANT ALL ON FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."batch_check_user_product_access"("product_slugs_param" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_application_rate_limit"("identifier_param" "text", "action_type_param" "text", "max_requests" integer, "window_minutes" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer, "time_window_seconds" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer, "time_window_seconds" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_rate_limit"("function_name_param" "text", "max_calls" integer, "time_window_seconds" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."check_refund_eligibility"("transaction_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_refund_eligibility"("transaction_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_refund_eligibility"("transaction_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_user_product_access"("product_slug_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_user_product_access"("product_slug_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_user_product_access"("product_slug_param" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_waitlist_config"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_waitlist_config"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_waitlist_config"() TO "service_role";



GRANT ALL ON FUNCTION "public"."claim_guest_purchases_for_user"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."claim_guest_purchases_for_user"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."claim_guest_purchases_for_user"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_application_rate_limits"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_application_rate_limits"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_application_rate_limits"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_audit_logs"("retention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_audit_logs"("retention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_audit_logs"("retention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_oto_coupons"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_oto_coupons"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_oto_coupons"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_admin_actions"("retention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_admin_actions"("retention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_admin_actions"("retention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_guest_purchases"("retention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_guest_purchases"("retention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_guest_purchases"("retention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_price_history"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_price_history"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_price_history"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"("retention_hours" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"("retention_hours" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"("retention_hours" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_rate_limits"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_rate_limits"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_rate_limits"() TO "service_role";



GRANT ALL ON FUNCTION "public"."clear_admin_cache"() TO "anon";
GRANT ALL ON FUNCTION "public"."clear_admin_cache"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."clear_admin_cache"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_refund_request"("transaction_id_param" "uuid", "reason_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_refund_request"("transaction_id_param" "uuid", "reason_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_refund_request"("transaction_id_param" "uuid", "reason_param" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."find_auto_apply_coupon"("customer_email_param" "text", "product_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."find_auto_apply_coupon"("customer_email_param" "text", "product_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_auto_apply_coupon"("customer_email_param" "text", "product_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_oto_coupon"("source_product_id_param" "uuid", "customer_email_param" "text", "transaction_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_admin_refund_requests"("status_filter" "text", "limit_param" integer, "offset_param" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_admin_refund_requests"("status_filter" "text", "limit_param" integer, "offset_param" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_admin_refund_requests"("status_filter" "text", "limit_param" integer, "offset_param" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_cleanup_job_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_cleanup_job_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cleanup_job_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_dashboard_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_dashboard_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_dashboard_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_detailed_revenue_stats"("p_product_id" "uuid", "p_goal_start_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."get_detailed_revenue_stats"("p_product_id" "uuid", "p_goal_start_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_detailed_revenue_stats"("p_product_id" "uuid", "p_goal_start_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_hourly_revenue_stats"("p_target_date" "date", "p_product_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_hourly_revenue_stats"("p_target_date" "date", "p_product_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_hourly_revenue_stats"("p_target_date" "date", "p_product_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_oto_coupon_info"("coupon_code_param" "text", "email_param" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_payment_statistics"("start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."get_payment_statistics"("start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_payment_statistics"("start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_product_order_bumps"("product_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_product_order_bumps"("product_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_product_order_bumps"("product_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_public_integrations_config"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_public_integrations_config"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_public_integrations_config"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_revenue_goal"("p_product_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_revenue_goal"("p_product_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_revenue_goal"("p_product_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_sales_chart_data"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_product_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_sales_chart_data"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_product_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sales_chart_data"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_product_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_payment_history"("user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_payment_history"("user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_payment_history"("user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_profile"("user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_profile"("user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_profile"("user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_purchases_with_refund_status"("user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_purchases_with_refund_status"("user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_purchases_with_refund_status"("user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_variant_group"("p_group_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_variant_group"("p_group_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_variant_group"("p_group_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_variant_group_by_slug"("p_slug" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."grant_free_product_access"("product_slug_param" "text", "access_duration_days_param" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."grant_product_access_service_role"("user_id_param" "uuid", "product_id_param" "uuid", "max_retries" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."grant_product_access_service_role"("user_id_param" "uuid", "product_id_param" "uuid", "max_retries" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."grant_product_access_service_role"("user_id_param" "uuid", "product_id_param" "uuid", "max_retries" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_sale_quantity_sold"("p_product_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"("user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"("user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"("user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin_cached"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin_cached"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin_cached"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_sale_price_active"("p_sale_price" numeric, "p_sale_price_until" timestamp with time zone, "p_sale_quantity_limit" integer, "p_sale_quantity_sold" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."log_admin_action"("action_name" "text", "target_type" "text", "target_id" "text", "action_details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_admin_action"("action_name" "text", "target_type" "text", "target_id" "text", "action_details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_admin_action"("action_name" "text", "target_type" "text", "target_id" "text", "action_details" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_admin_action_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_admin_action_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_admin_action_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_audit_entry"("table_name_param" "text", "operation_param" "text", "old_values_param" "jsonb", "new_values_param" "jsonb", "user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."log_audit_entry"("table_name_param" "text", "operation_param" "text", "old_values_param" "jsonb", "new_values_param" "jsonb", "user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_audit_entry"("table_name_param" "text", "operation_param" "text", "old_values_param" "jsonb", "new_values_param" "jsonb", "user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_product_price_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_product_price_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_product_price_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."logs_monitoring_check"("new_action_details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."logs_monitoring_check"("new_action_details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."logs_monitoring_check"("new_action_details" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."logs_monitoring_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."logs_monitoring_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."logs_monitoring_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_refund_request"("request_id_param" "uuid", "action_param" "text", "admin_response_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_refund_request"("request_id_param" "uuid", "action_param" "text", "admin_response_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_refund_request"("request_id_param" "uuid", "action_param" "text", "admin_response_param" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion_with_bump"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid", "bump_product_id_param" "uuid", "coupon_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion_with_bump"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid", "bump_product_id_param" "uuid", "coupon_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_stripe_payment_completion_with_bump"("session_id_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "amount_total" numeric, "currency_param" "text", "stripe_payment_intent_id" "text", "user_id_param" "uuid", "bump_product_id_param" "uuid", "coupon_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."send_monitoring_email"("alert_type" "text", "alert_details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."send_monitoring_email"("alert_type" "text", "alert_details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."send_monitoring_email"("alert_type" "text", "alert_details" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_revenue_goal"("p_goal_amount" bigint, "p_start_date" timestamp with time zone, "p_product_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."set_revenue_goal"("p_goal_amount" bigint, "p_start_date" timestamp with time zone, "p_product_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_revenue_goal"("p_goal_amount" bigint, "p_start_date" timestamp with time zone, "p_product_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_refund_request_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_refund_request_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_refund_request_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_refunded_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_refunded_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_refunded_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_video_progress"("product_id_param" "uuid", "video_id_param" "text", "position_param" integer, "duration_param" integer, "completed_param" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."update_video_progress"("product_id_param" "uuid", "video_id_param" "text", "position_param" integer, "duration_param" integer, "completed_param" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_video_progress"("product_id_param" "uuid", "video_id_param" "text", "position_param" integer, "duration_param" integer, "completed_param" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_email_format"("email_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_email_format"("email_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_email_format"("email_param" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_payment_transaction"("transaction_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_payment_transaction"("transaction_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_payment_transaction"("transaction_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."verify_api_key"("p_key_hash" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."verify_api_key"("p_key_hash" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."verify_api_key"("p_key_hash" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."verify_coupon"("code_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "currency_param" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."verify_coupon"("code_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "currency_param" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."verify_coupon"("code_param" "text", "product_id_param" "uuid", "customer_email_param" "text", "currency_param" "text") TO "service_role";
























GRANT ALL ON TABLE "public"."admin_actions" TO "anon";
GRANT ALL ON TABLE "public"."admin_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_actions" TO "service_role";



GRANT ALL ON TABLE "public"."admin_users" TO "anon";
GRANT ALL ON TABLE "public"."admin_users" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_users" TO "service_role";



GRANT ALL ON TABLE "public"."api_key_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."api_key_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."api_key_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."api_keys" TO "anon";
GRANT ALL ON TABLE "public"."api_keys" TO "authenticated";
GRANT ALL ON TABLE "public"."api_keys" TO "service_role";



GRANT ALL ON TABLE "public"."application_rate_limits" TO "anon";
GRANT ALL ON TABLE "public"."application_rate_limits" TO "authenticated";
GRANT ALL ON TABLE "public"."application_rate_limits" TO "service_role";



GRANT ALL ON TABLE "public"."audit_log" TO "anon";
GRANT ALL ON TABLE "public"."audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."categories" TO "anon";
GRANT ALL ON TABLE "public"."categories" TO "authenticated";
GRANT ALL ON TABLE "public"."categories" TO "service_role";



GRANT ALL ON TABLE "public"."consent_logs" TO "anon";
GRANT ALL ON TABLE "public"."consent_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."consent_logs" TO "service_role";



GRANT ALL ON TABLE "public"."coupon_redemptions" TO "anon";
GRANT ALL ON TABLE "public"."coupon_redemptions" TO "authenticated";
GRANT ALL ON TABLE "public"."coupon_redemptions" TO "service_role";



GRANT ALL ON TABLE "public"."coupon_reservations" TO "anon";
GRANT ALL ON TABLE "public"."coupon_reservations" TO "authenticated";
GRANT ALL ON TABLE "public"."coupon_reservations" TO "service_role";



GRANT ALL ON TABLE "public"."coupons" TO "anon";
GRANT ALL ON TABLE "public"."coupons" TO "authenticated";
GRANT ALL ON TABLE "public"."coupons" TO "service_role";



GRANT ALL ON TABLE "public"."custom_scripts" TO "anon";
GRANT ALL ON TABLE "public"."custom_scripts" TO "authenticated";
GRANT ALL ON TABLE "public"."custom_scripts" TO "service_role";



GRANT ALL ON TABLE "public"."guest_purchases" TO "anon";
GRANT ALL ON TABLE "public"."guest_purchases" TO "authenticated";
GRANT ALL ON TABLE "public"."guest_purchases" TO "service_role";



GRANT ALL ON TABLE "public"."integrations_config" TO "anon";
GRANT ALL ON TABLE "public"."integrations_config" TO "authenticated";
GRANT ALL ON TABLE "public"."integrations_config" TO "service_role";



GRANT ALL ON TABLE "public"."order_bumps" TO "anon";
GRANT ALL ON TABLE "public"."order_bumps" TO "authenticated";
GRANT ALL ON TABLE "public"."order_bumps" TO "service_role";



GRANT ALL ON TABLE "public"."oto_offers" TO "anon";
GRANT ALL ON TABLE "public"."oto_offers" TO "authenticated";
GRANT ALL ON TABLE "public"."oto_offers" TO "service_role";



GRANT ALL ON TABLE "public"."payment_transactions" TO "anon";
GRANT ALL ON TABLE "public"."payment_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."payment_system_health" TO "service_role";



GRANT ALL ON TABLE "public"."product_categories" TO "anon";
GRANT ALL ON TABLE "public"."product_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."product_categories" TO "service_role";



GRANT ALL ON TABLE "public"."product_price_history" TO "anon";
GRANT ALL ON TABLE "public"."product_price_history" TO "authenticated";
GRANT ALL ON TABLE "public"."product_price_history" TO "service_role";



GRANT ALL ON TABLE "public"."product_tags" TO "anon";
GRANT ALL ON TABLE "public"."product_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."product_tags" TO "service_role";



GRANT ALL ON TABLE "public"."product_variant_groups" TO "anon";
GRANT ALL ON TABLE "public"."product_variant_groups" TO "authenticated";
GRANT ALL ON TABLE "public"."product_variant_groups" TO "service_role";



GRANT ALL ON TABLE "public"."products" TO "anon";
GRANT ALL ON TABLE "public"."products" TO "authenticated";
GRANT ALL ON TABLE "public"."products" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."rate_limits" TO "anon";
GRANT ALL ON TABLE "public"."rate_limits" TO "authenticated";
GRANT ALL ON TABLE "public"."rate_limits" TO "service_role";



GRANT ALL ON TABLE "public"."rate_limit_summary" TO "service_role";



GRANT ALL ON TABLE "public"."refund_requests" TO "anon";
GRANT ALL ON TABLE "public"."refund_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."refund_requests" TO "service_role";



GRANT ALL ON TABLE "public"."revenue_goals" TO "anon";
GRANT ALL ON TABLE "public"."revenue_goals" TO "authenticated";
GRANT ALL ON TABLE "public"."revenue_goals" TO "service_role";



GRANT ALL ON TABLE "public"."shop_config" TO "anon";
GRANT ALL ON TABLE "public"."shop_config" TO "authenticated";
GRANT ALL ON TABLE "public"."shop_config" TO "service_role";



GRANT ALL ON TABLE "public"."stripe_configurations" TO "anon";
GRANT ALL ON TABLE "public"."stripe_configurations" TO "authenticated";
GRANT ALL ON TABLE "public"."stripe_configurations" TO "service_role";



GRANT ALL ON TABLE "public"."tags" TO "anon";
GRANT ALL ON TABLE "public"."tags" TO "authenticated";
GRANT ALL ON TABLE "public"."tags" TO "service_role";



GRANT ALL ON TABLE "public"."user_product_access" TO "anon";
GRANT ALL ON TABLE "public"."user_product_access" TO "authenticated";
GRANT ALL ON TABLE "public"."user_product_access" TO "service_role";



GRANT ALL ON TABLE "public"."user_access_stats" TO "service_role";



GRANT ALL ON TABLE "public"."user_product_access_detailed" TO "service_role";



GRANT ALL ON TABLE "public"."variant_groups" TO "anon";
GRANT ALL ON TABLE "public"."variant_groups" TO "authenticated";
GRANT ALL ON TABLE "public"."variant_groups" TO "service_role";



GRANT ALL ON TABLE "public"."video_events" TO "anon";
GRANT ALL ON TABLE "public"."video_events" TO "authenticated";
GRANT ALL ON TABLE "public"."video_events" TO "service_role";



GRANT ALL ON TABLE "public"."video_progress" TO "anon";
GRANT ALL ON TABLE "public"."video_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."video_progress" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_endpoints" TO "anon";
GRANT ALL ON TABLE "public"."webhook_endpoints" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_endpoints" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_logs" TO "anon";
GRANT ALL ON TABLE "public"."webhook_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_logs" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























