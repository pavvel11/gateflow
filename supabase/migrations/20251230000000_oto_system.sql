-- =====================================================
-- GateFlow - True OTO (One-Time Offer) System
-- =====================================================
-- Description: Server-side validated one-time offers with time-limited,
--              email-bound coupons that cannot be bypassed.
-- Created: 2025-12-30
--
-- Flow:
--   Purchase Product A → Generate OTO Coupon (X minutes) → Redirect to Product B
--   → Coupon auto-applies → Timer countdown → Expires = normal price
-- =====================================================

-- Suppress NOTICE messages during migration (e.g., "relation already exists, skipping")
SET client_min_messages = warning;

-- =============================================================================
-- TABLES
-- =============================================================================

-- -----------------------------------------------------------------------------
-- OTO OFFERS TABLE
-- -----------------------------------------------------------------------------
-- Defines OTO relationships: "After buying Product A, offer Product B at X% off"

CREATE TABLE IF NOT EXISTS public.oto_offers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- Product relationships
  source_product_id UUID REFERENCES public.products(id) ON DELETE CASCADE NOT NULL,
  oto_product_id UUID REFERENCES public.products(id) ON DELETE CASCADE NOT NULL,

  -- Discount configuration
  discount_type TEXT NOT NULL CHECK (discount_type IN ('percentage', 'fixed')),
  discount_value NUMERIC NOT NULL CHECK (discount_value > 0),

  -- Time configuration
  duration_minutes INTEGER DEFAULT 15 NOT NULL CHECK (duration_minutes > 0 AND duration_minutes <= 1440),

  -- Status
  is_active BOOLEAN DEFAULT true NOT NULL,
  display_order INTEGER DEFAULT 0 NOT NULL,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,

  -- Constraints
  CONSTRAINT no_self_oto CHECK (source_product_id != oto_product_id),
  CONSTRAINT unique_oto_pair UNIQUE (source_product_id, oto_product_id),
  CONSTRAINT valid_percentage_discount CHECK (
    discount_type != 'percentage' OR discount_value <= 100
  )
);

COMMENT ON TABLE public.oto_offers IS 'OTO (One-Time Offer) configurations - defines which product to offer after purchasing another';
COMMENT ON COLUMN public.oto_offers.source_product_id IS 'The product that triggers the OTO after purchase';
COMMENT ON COLUMN public.oto_offers.oto_product_id IS 'The product offered as OTO with a discount';
COMMENT ON COLUMN public.oto_offers.duration_minutes IS 'How long the OTO coupon is valid (default: 15 minutes, max: 24 hours)';

-- -----------------------------------------------------------------------------
-- EXTEND COUPONS TABLE FOR OTO
-- -----------------------------------------------------------------------------

ALTER TABLE public.coupons
ADD COLUMN IF NOT EXISTS is_oto_coupon BOOLEAN DEFAULT false NOT NULL,
ADD COLUMN IF NOT EXISTS oto_offer_id UUID REFERENCES public.oto_offers(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS source_transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE SET NULL;

COMMENT ON COLUMN public.coupons.is_oto_coupon IS 'True if this coupon was auto-generated by the OTO system';
COMMENT ON COLUMN public.coupons.oto_offer_id IS 'Reference to the OTO offer that generated this coupon';
COMMENT ON COLUMN public.coupons.source_transaction_id IS 'The transaction that triggered OTO coupon generation';

-- =============================================================================
-- INDEXES
-- =============================================================================

-- OTO offers indexes
CREATE INDEX IF NOT EXISTS idx_oto_offers_source_product
  ON public.oto_offers(source_product_id, is_active, display_order);
CREATE INDEX IF NOT EXISTS idx_oto_offers_oto_product
  ON public.oto_offers(oto_product_id);

-- Coupons OTO indexes
CREATE INDEX IF NOT EXISTS idx_coupons_oto
  ON public.coupons(is_oto_coupon) WHERE is_oto_coupon = true;
CREATE INDEX IF NOT EXISTS idx_coupons_oto_expires
  ON public.coupons(expires_at) WHERE is_oto_coupon = true;
CREATE INDEX IF NOT EXISTS idx_coupons_source_transaction
  ON public.coupons(source_transaction_id) WHERE source_transaction_id IS NOT NULL;

-- UNIQUE constraint to prevent duplicate OTO coupons for same transaction (race condition protection)
CREATE UNIQUE INDEX IF NOT EXISTS idx_coupons_oto_transaction_unique
  ON public.coupons(source_transaction_id)
  WHERE source_transaction_id IS NOT NULL AND is_oto_coupon = true;

-- =============================================================================
-- FUNCTIONS
-- =============================================================================

-- -----------------------------------------------------------------------------
-- GENERATE OTO COUPON
-- -----------------------------------------------------------------------------
-- Called after successful payment to create a time-limited, email-bound coupon

CREATE OR REPLACE FUNCTION public.generate_oto_coupon(
  source_product_id_param UUID,
  customer_email_param TEXT,
  transaction_id_param UUID
) RETURNS JSONB AS $$
DECLARE
  oto_config RECORD;
  oto_product RECORD;
  existing_coupon RECORD;
  new_coupon_code TEXT;
  new_coupon_id UUID;
  coupon_expires_at TIMESTAMPTZ;
BEGIN
  -- IDEMPOTENCY CHECK: Check if OTO coupon already exists for this transaction
  SELECT c.id, c.code, c.discount_type, c.discount_value, c.expires_at,
         o.oto_product_id, p.slug as oto_product_slug, p.name as oto_product_name,
         p.price as oto_product_price, p.currency as oto_product_currency,
         o.duration_minutes
  INTO existing_coupon
  FROM public.coupons c
  INNER JOIN public.oto_offers o ON c.oto_offer_id = o.id
  INNER JOIN public.products p ON o.oto_product_id = p.id
  WHERE c.source_transaction_id = transaction_id_param
    AND c.is_oto_coupon = true
  LIMIT 1;

  -- If coupon already exists for this transaction, return existing info
  IF existing_coupon IS NOT NULL THEN
    RETURN jsonb_build_object(
      'has_oto', true,
      'coupon_code', existing_coupon.code,
      'coupon_id', existing_coupon.id,
      'oto_product_id', existing_coupon.oto_product_id,
      'oto_product_slug', existing_coupon.oto_product_slug,
      'oto_product_name', existing_coupon.oto_product_name,
      'oto_product_price', existing_coupon.oto_product_price,
      'oto_product_currency', existing_coupon.oto_product_currency,
      'discount_type', existing_coupon.discount_type,
      'discount_value', existing_coupon.discount_value,
      'expires_at', existing_coupon.expires_at,
      'duration_minutes', existing_coupon.duration_minutes
    );
  END IF;

  -- Find active OTO offer for this product
  SELECT o.*, p.slug as oto_product_slug, p.name as oto_product_name, p.price as oto_product_price, p.currency as oto_product_currency
  INTO oto_config
  FROM public.oto_offers o
  INNER JOIN public.products p ON p.id = o.oto_product_id AND p.is_active = true
  WHERE o.source_product_id = source_product_id_param
    AND o.is_active = true
  ORDER BY o.display_order ASC, o.created_at ASC
  LIMIT 1;

  -- No OTO configured
  IF oto_config IS NULL THEN
    RETURN jsonb_build_object('has_oto', false);
  END IF;

  -- CHECK: Does customer already own the OTO product?
  -- Check 1: user_product_access (logged-in users, by email via auth.users)
  IF EXISTS (
    SELECT 1
    FROM public.user_product_access upa
    INNER JOIN auth.users au ON au.id = upa.user_id
    WHERE au.email = customer_email_param
      AND upa.product_id = oto_config.oto_product_id
      AND (upa.access_expires_at IS NULL OR upa.access_expires_at > NOW())
  ) THEN
    RETURN jsonb_build_object(
      'has_oto', false,
      'reason', 'already_owns_oto_product',
      'skipped_oto_product_id', oto_config.oto_product_id,
      'skipped_oto_product_slug', oto_config.oto_product_slug
    );
  END IF;

  -- Check 2: guest_purchases (guest users, by email directly)
  IF EXISTS (
    SELECT 1
    FROM public.guest_purchases gp
    WHERE gp.customer_email = customer_email_param
      AND gp.product_id = oto_config.oto_product_id
  ) THEN
    RETURN jsonb_build_object(
      'has_oto', false,
      'reason', 'already_owns_oto_product',
      'skipped_oto_product_id', oto_config.oto_product_id,
      'skipped_oto_product_slug', oto_config.oto_product_slug
    );
  END IF;

  -- Generate unique coupon code (OTO-XXXXXXXX format)
  new_coupon_code := 'OTO-' || UPPER(SUBSTRING(REPLACE(gen_random_uuid()::TEXT, '-', ''), 1, 8));
  coupon_expires_at := NOW() + (oto_config.duration_minutes || ' minutes')::INTERVAL;

  -- Create the OTO coupon with race condition protection
  -- Use BEGIN/EXCEPTION to handle unique constraint violation
  BEGIN
    INSERT INTO public.coupons (
      code,
      name,
      discount_type,
      discount_value,
      currency,
      allowed_emails,
      allowed_product_ids,
      usage_limit_global,
      usage_limit_per_user,
      expires_at,
      is_active,
      is_oto_coupon,
      oto_offer_id,
      source_transaction_id
    ) VALUES (
      new_coupon_code,
      'OTO: ' || customer_email_param,
      oto_config.discount_type,
      oto_config.discount_value,
      CASE WHEN oto_config.discount_type = 'fixed' THEN oto_config.oto_product_currency ELSE NULL END,
      jsonb_build_array(customer_email_param),
      jsonb_build_array(oto_config.oto_product_id),
      1,  -- Can only be used once
      1,  -- By one person
      coupon_expires_at,
      true,
      true,
      oto_config.id,
      transaction_id_param
    )
    RETURNING id INTO new_coupon_id;
  EXCEPTION
    WHEN unique_violation THEN
      -- Race condition: another process already created the coupon
      -- Return the existing coupon instead
      SELECT c.id, c.code, c.discount_type, c.discount_value, c.expires_at,
             o.oto_product_id, p.slug as oto_product_slug, p.name as oto_product_name,
             p.price as oto_product_price, p.currency as oto_product_currency,
             o.duration_minutes
      INTO existing_coupon
      FROM public.coupons c
      INNER JOIN public.oto_offers o ON c.oto_offer_id = o.id
      INNER JOIN public.products p ON o.oto_product_id = p.id
      WHERE c.source_transaction_id = transaction_id_param
        AND c.is_oto_coupon = true
      LIMIT 1;

      IF existing_coupon IS NOT NULL THEN
        RETURN jsonb_build_object(
          'has_oto', true,
          'coupon_code', existing_coupon.code,
          'coupon_id', existing_coupon.id,
          'oto_product_id', existing_coupon.oto_product_id,
          'oto_product_slug', existing_coupon.oto_product_slug,
          'oto_product_name', existing_coupon.oto_product_name,
          'oto_product_price', existing_coupon.oto_product_price,
          'oto_product_currency', existing_coupon.oto_product_currency,
          'discount_type', existing_coupon.discount_type,
          'discount_value', existing_coupon.discount_value,
          'expires_at', existing_coupon.expires_at,
          'duration_minutes', existing_coupon.duration_minutes
        );
      END IF;
  END;

  -- Return OTO info for redirect
  RETURN jsonb_build_object(
    'has_oto', true,
    'coupon_code', new_coupon_code,
    'coupon_id', new_coupon_id,
    'oto_product_id', oto_config.oto_product_id,
    'oto_product_slug', oto_config.oto_product_slug,
    'oto_product_name', oto_config.oto_product_name,
    'oto_product_price', oto_config.oto_product_price,
    'oto_product_currency', oto_config.oto_product_currency,
    'discount_type', oto_config.discount_type,
    'discount_value', oto_config.discount_value,
    'expires_at', coupon_expires_at,
    'duration_minutes', oto_config.duration_minutes
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.generate_oto_coupon TO service_role;

-- -----------------------------------------------------------------------------
-- GET OTO COUPON INFO
-- -----------------------------------------------------------------------------
-- Returns OTO coupon details for frontend timer display

CREATE OR REPLACE FUNCTION public.get_oto_coupon_info(
  coupon_code_param TEXT,
  email_param TEXT
) RETURNS JSONB AS $$
DECLARE
  coupon_record RECORD;
  seconds_left INTEGER;
BEGIN
  -- Find valid OTO coupon for this email
  SELECT
    c.id,
    c.code,
    c.discount_type,
    c.discount_value,
    c.expires_at,
    o.duration_minutes,
    p.id as product_id,
    p.slug as product_slug,
    p.name as product_name,
    p.price as product_price,
    p.currency as product_currency
  INTO coupon_record
  FROM public.coupons c
  LEFT JOIN public.oto_offers o ON c.oto_offer_id = o.id
  LEFT JOIN public.products p ON o.oto_product_id = p.id
  WHERE c.code = coupon_code_param
    AND c.is_oto_coupon = true
    AND c.is_active = true
    AND c.expires_at > NOW()
    AND c.current_usage_count < COALESCE(c.usage_limit_global, 999999)
    AND c.allowed_emails ? email_param;

  IF coupon_record IS NULL THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Coupon not found or expired'
    );
  END IF;

  -- Calculate seconds remaining
  seconds_left := GREATEST(0, EXTRACT(EPOCH FROM (coupon_record.expires_at - NOW()))::INTEGER);

  RETURN jsonb_build_object(
    'valid', true,
    'coupon_id', coupon_record.id,
    'code', coupon_record.code,
    'discount_type', coupon_record.discount_type,
    'discount_value', coupon_record.discount_value,
    'expires_at', coupon_record.expires_at,
    'seconds_remaining', seconds_left,
    'duration_minutes', coupon_record.duration_minutes,
    'product', jsonb_build_object(
      'id', coupon_record.product_id,
      'slug', coupon_record.product_slug,
      'name', coupon_record.product_name,
      'price', coupon_record.product_price,
      'currency', coupon_record.product_currency
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.get_oto_coupon_info TO anon, authenticated, service_role;

-- -----------------------------------------------------------------------------
-- CLEANUP EXPIRED OTO COUPONS
-- -----------------------------------------------------------------------------
-- Deletes expired, unused OTO coupons for database hygiene
-- Note: Expired coupons won't work anyway (verify_coupon checks expires_at)
-- This function is ready to be called by pg_cron or external trigger

CREATE OR REPLACE FUNCTION public.cleanup_expired_oto_coupons()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete OTO coupons that:
  -- 1. Are OTO coupons
  -- 2. Expired more than 1 hour ago (grace period)
  -- 3. Were never used
  DELETE FROM public.coupons
  WHERE is_oto_coupon = true
    AND expires_at < NOW() - INTERVAL '1 hour'
    AND current_usage_count = 0;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  -- Optional: Log cleanup
  -- RAISE NOTICE 'Cleaned up % expired OTO coupons', deleted_count;

  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.cleanup_expired_oto_coupons TO service_role;

-- -----------------------------------------------------------------------------
-- ADMIN: GET OTO OFFERS FOR PRODUCT
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.admin_get_product_oto_offer(
  product_id_param UUID
) RETURNS JSONB AS $$
DECLARE
  oto_record RECORD;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Get OTO offer for this product
  SELECT
    o.*,
    p.name as oto_product_name,
    p.slug as oto_product_slug,
    p.price as oto_product_price,
    p.currency as oto_product_currency
  INTO oto_record
  FROM public.oto_offers o
  INNER JOIN public.products p ON p.id = o.oto_product_id
  WHERE o.source_product_id = product_id_param
  ORDER BY o.display_order ASC
  LIMIT 1;

  IF oto_record IS NULL THEN
    RETURN jsonb_build_object('has_oto', false);
  END IF;

  RETURN jsonb_build_object(
    'has_oto', true,
    'id', oto_record.id,
    'oto_product_id', oto_record.oto_product_id,
    'oto_product_name', oto_record.oto_product_name,
    'oto_product_slug', oto_record.oto_product_slug,
    'oto_product_price', oto_record.oto_product_price,
    'oto_product_currency', oto_record.oto_product_currency,
    'discount_type', oto_record.discount_type,
    'discount_value', oto_record.discount_value,
    'duration_minutes', oto_record.duration_minutes,
    'is_active', oto_record.is_active
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.admin_get_product_oto_offer TO authenticated;

-- -----------------------------------------------------------------------------
-- ADMIN: SAVE OTO OFFER
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.admin_save_oto_offer(
  source_product_id_param UUID,
  oto_product_id_param UUID,
  discount_type_param TEXT,
  discount_value_param NUMERIC,
  duration_minutes_param INTEGER DEFAULT 15,
  is_active_param BOOLEAN DEFAULT true
) RETURNS JSONB AS $$
DECLARE
  result_id UUID;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Validate inputs
  IF source_product_id_param = oto_product_id_param THEN
    RETURN jsonb_build_object('success', false, 'error', 'Source and OTO product cannot be the same');
  END IF;

  IF discount_type_param NOT IN ('percentage', 'fixed') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid discount type');
  END IF;

  IF discount_type_param = 'percentage' AND discount_value_param > 100 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Percentage discount cannot exceed 100%');
  END IF;

  IF duration_minutes_param < 1 OR duration_minutes_param > 1440 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Duration must be between 1 and 1440 minutes');
  END IF;

  -- Upsert OTO offer
  INSERT INTO public.oto_offers (
    source_product_id,
    oto_product_id,
    discount_type,
    discount_value,
    duration_minutes,
    is_active
  ) VALUES (
    source_product_id_param,
    oto_product_id_param,
    discount_type_param,
    discount_value_param,
    duration_minutes_param,
    is_active_param
  )
  ON CONFLICT (source_product_id, oto_product_id) DO UPDATE SET
    discount_type = EXCLUDED.discount_type,
    discount_value = EXCLUDED.discount_value,
    duration_minutes = EXCLUDED.duration_minutes,
    is_active = EXCLUDED.is_active,
    updated_at = NOW()
  RETURNING id INTO result_id;

  RETURN jsonb_build_object(
    'success', true,
    'id', result_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.admin_save_oto_offer TO authenticated;

-- -----------------------------------------------------------------------------
-- ADMIN: DELETE OTO OFFER
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.admin_delete_oto_offer(
  source_product_id_param UUID
) RETURNS JSONB AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Check admin access
  IF NOT EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  DELETE FROM public.oto_offers
  WHERE source_product_id = source_product_id_param;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RETURN jsonb_build_object(
    'success', true,
    'deleted', deleted_count
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

GRANT EXECUTE ON FUNCTION public.admin_delete_oto_offer TO authenticated;

-- =============================================================================
-- TRIGGERS
-- =============================================================================

-- Updated at trigger for oto_offers
CREATE TRIGGER trigger_update_oto_offers_updated_at
  BEFORE UPDATE ON public.oto_offers
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =============================================================================
-- ROW LEVEL SECURITY (RLS)
-- =============================================================================

ALTER TABLE public.oto_offers ENABLE ROW LEVEL SECURITY;

-- Admin full access to oto_offers
CREATE POLICY "Admins can manage oto_offers" ON public.oto_offers
  FOR ALL TO authenticated
  USING (EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = auth.uid()));

-- Service role full access
CREATE POLICY "Service role full access to oto_offers" ON public.oto_offers
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Public can view active OTO offers (needed for product page to know if OTO exists)
CREATE POLICY "Public can view active oto_offers" ON public.oto_offers
  FOR SELECT TO anon, authenticated USING (is_active = true);

-- =============================================================================
-- COMMENTS
-- =============================================================================

COMMENT ON FUNCTION public.generate_oto_coupon IS 'Generates a time-limited, email-bound coupon for OTO after purchase';
COMMENT ON FUNCTION public.get_oto_coupon_info IS 'Returns OTO coupon details for frontend timer display';
COMMENT ON FUNCTION public.cleanup_expired_oto_coupons IS 'Cleanup function for expired OTO coupons - call via pg_cron or external trigger';
COMMENT ON FUNCTION public.admin_get_product_oto_offer IS 'Get OTO configuration for a product (admin only)';
COMMENT ON FUNCTION public.admin_save_oto_offer IS 'Create or update OTO offer for a product (admin only)';
COMMENT ON FUNCTION public.admin_delete_oto_offer IS 'Delete OTO offer for a product (admin only)';
