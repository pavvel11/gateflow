/**
 * Config.js Generator
 * Generates dynamic Supabase configuration scripts
 */

import { JSProcessor } from './js-processor';

interface ConfigOptions {
  supabaseUrl: string;
  supabaseAnonKey: string;
  environment: string;
  includeComments?: boolean;
  format?: 'module' | 'global';
  customDomain?: string;
}

interface GeneratedConfig {
  content: string;
  hash: string;
  lastModified: Date;
  metadata: {
    environment: string;
    format: string;
    size: number;
  };
}

interface ConfigComments {
  urlComment: string;
  keyComment: string;
  clientComment: string;
  usage: string;
}

/**
 * Template-based config generator with caching
 */
export class ConfigGenerator {
  private static cache = new Map<string, GeneratedConfig>();
  private static readonly CACHE_TTL = 1000 * 60 * 30; // 30 minutes

  /**
   * Generate the complete config script with proper formatting
   */
  static async generateConfig(options: ConfigOptions): Promise<GeneratedConfig> {
    const cacheKey = this.getCacheKey(options);
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached && this.isCacheValid(cached)) {
      return cached;
    }

    // Generate new config
    let content = this.buildConfigScript(options);
    
    // Process the script (minify/obfuscate) in production
    const processingConfig = JSProcessor.getConfigForEnvironment(
      options.environment as 'development' | 'production'
    );
    content = await JSProcessor.processCode(content, processingConfig);
    
    const hash = this.generateHash(content);
    
    const generated: GeneratedConfig = {
      content,
      hash,
      lastModified: new Date(),
      metadata: {
        environment: options.environment,
        format: options.format || 'module',
        size: content.length
      }
    };

    // Cache the result
    this.cache.set(cacheKey, generated);
    
    // Clean old cache entries
    this.cleanCache();
    
    return generated;
  }

  /**
   * Build the complete config script
   */
  private static buildConfigScript(options: ConfigOptions): string {
    const {
      supabaseUrl,
      supabaseAnonKey,
      environment,
      format = 'module'
    } = options;

    // Security: Escape strings for JavaScript
    const escapeJSString = (str: string): string => {
      return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
    };
    
    const safeUrl = escapeJSString(supabaseUrl);
    const safeKey = escapeJSString(supabaseAnonKey);
    
    const header = this.generateHeader(options);
    const comments = this.generateComments(options);
    
    if (format === 'global') {
      return this.generateGlobalFormat(safeUrl, safeKey, environment, header, comments);
    } else {
      return this.generateModuleFormat(safeUrl, safeKey, environment, header, comments);
    }
  }

  /**
   * Generate script header with metadata
   */
  private static generateHeader(options: ConfigOptions): string {
    if (!options.includeComments) return '';
    
    return `/*!
 * Supabase Config.js v1.0.0
 * Generated by GateFlow Admin Panel
 * 
 * Build: ${new Date().toISOString()}
 * Environment: ${options.environment}
 * Format: ${options.format || 'module'}
 * ${options.customDomain ? `Domain: ${options.customDomain}` : ''}
 * 
 * @description Dynamic Supabase configuration
 * @usage Include this script before using Supabase in your application
 * @website https://gateflow.pl
 */

`;
  }

  /**
   * Generate helpful comments
   */
  private static generateComments(options: ConfigOptions): ConfigComments {
    if (!options.includeComments) {
      return {
        urlComment: '',
        keyComment: '',
        clientComment: '',
        usage: ''
      };
    }

    return {
      urlComment: ` // Generated from ${options.environment} environment`,
      keyComment: ` // Auto-generated anon key`,
      clientComment: `
// Initialize Supabase client
// This creates a global 'supabase' constant that can be used throughout your application`,
      usage: `

/*
 * USAGE EXAMPLES:
 * 
 * // Basic database queries:
 * const { data, error } = await supabase.from('table').select('*');
 * 
 * // Authentication with magic links:
 * const { error } = await supabase.auth.signInWithOtp({ 
 *   email: 'user@example.com',
 *   options: { emailRedirectTo: 'https://yoursite.com/callback' }
 * });
 * 
 * // Real-time subscriptions:
 * const channel = supabase.channel('table-changes')
 *   .on('postgres_changes', { event: '*', schema: 'public', table: 'your_table' }, (payload) => {
 *     console.log('Change received!', payload);
 *   })
 *   .subscribe();
 * 
 * // File uploads:
 * const { data, error } = await supabase.storage
 *   .from('bucket')
 *   .upload('path/to/file.jpg', file);
 */`
    };
  }

  /**
   * Generate global format script
   */
  private static generateGlobalFormat(
    safeUrl: string,
    safeKey: string,
    environment: string,
    header: string,
    comments: ConfigComments
  ): string {
    return `${header}// Global Supabase Configuration${comments.urlComment}
window.SUPABASE_CONFIG = {
  url: '${safeUrl}',
  anonKey: '${safeKey}',
  environment: '${environment}',
  generatedAt: '${new Date().toISOString()}'
};${comments.clientComment}

// Initialize Supabase client if the library is loaded
if (typeof window !== 'undefined' && window.supabase) {
  window.supabaseClient = window.supabase.createClient(
    window.SUPABASE_CONFIG.url,
    window.SUPABASE_CONFIG.anonKey
  );
  
  // Also create a global supabase constant for backward compatibility
  window.supabase = window.supabaseClient;
} else {
  console.warn('Supabase library not loaded. Please include the Supabase CDN script first.');
}${comments.usage}
`;
  }

  /**
   * Generate module format script (default, backward compatible)
   */
  private static generateModuleFormat(
    safeUrl: string,
    safeKey: string,
    environment: string,
    header: string,
    comments: ConfigComments
  ): string {
    return `${header}// Supabase Configuration${comments.urlComment}
const SUPABASE_URL = '${safeUrl}';${comments.keyComment}
const SUPABASE_ANON_KEY = '${safeKey}';

// Configuration metadata
const SUPABASE_CONFIG = {
  url: SUPABASE_URL,
  anonKey: SUPABASE_ANON_KEY,
  environment: '${environment}',
  generatedAt: '${new Date().toISOString()}'
};${comments.clientComment}

// Initialize Supabase client
// The Supabase CDN script creates a global 'supabase' object on the window
// We initialize the client here and assign it to a constant with the same name
if (typeof window !== 'undefined' && window.supabase) {
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  
  // Make it available globally for easier access
  window.supabaseClient = supabase;
} else {
  console.warn('Supabase library not loaded. Please include the Supabase CDN script first.');
}${comments.usage}
`;
  }

  /**
   * Generate cache key for configuration
   */
  private static getCacheKey(options: ConfigOptions): string {
    return `config_${options.environment}_${options.format}_${options.includeComments}_${this.generateHash(options.supabaseUrl + options.supabaseAnonKey)}`;
  }

  /**
   * Check if cache entry is still valid
   */
  private static isCacheValid(cached: GeneratedConfig): boolean {
    return Date.now() - cached.lastModified.getTime() < this.CACHE_TTL;
  }

  /**
   * Generate hash for content
   */
  private static generateHash(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(36);
  }

  /**
   * Clean old cache entries
   */
  private static cleanCache(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.lastModified.getTime() > this.CACHE_TTL) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Get cache statistics
   */
  static getCacheStats() {
    return {
      size: this.cache.size,
      entries: Array.from(this.cache.entries()).map(([key, value]) => ({
        key,
        lastModified: value.lastModified,
        size: value.content.length,
        environment: value.metadata.environment,
        format: value.metadata.format
      }))
    };
  }

  /**
   * Clear cache manually
   */
  static clearCache(): void {
    this.cache.clear();
  }
}
