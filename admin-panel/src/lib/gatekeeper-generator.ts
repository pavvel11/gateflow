/**
 * GateKeeper.js Generator
 * Generates dynamic JavaScript with proper configuration injection
 */

import { JSProcessor } from './js-processor';

interface GatekeeperConfig {
  supabaseUrl: string;
  supabaseAnonKey: string;
  version: string;
  environment: string;
  mainDomain: string;
  productSlug?: string;
  licenseValid?: boolean;
  features?: {
    analytics?: boolean;
    watermark?: boolean;
    debugging?: boolean;
  };
}

interface GeneratedScript {
  content: string;
  hash: string;
  lastModified: Date;
}

/**
 * Template-based approach with proper escaping and injection
 */
export class GatekeeperGenerator {
  private static cache = new Map<string, GeneratedScript>();
  private static readonly CACHE_TTL = 1000 * 60 * 60; // 1 hour

  /**
   * Generate the complete gatekeeper script with injected configuration
   */
  static async generateScript(config: GatekeeperConfig): Promise<GeneratedScript> {
    const cacheKey = this.getCacheKey(config);
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached && this.isCacheValid(cached)) {
      return cached;
    }

    // Generate new script
    let content = await this.buildScript(config);
    
    // Process the script (minify/obfuscate) in production
    const processingConfig = JSProcessor.getConfigForEnvironment(
      config.environment as 'development' | 'production'
    );
    content = await JSProcessor.processCode(content, processingConfig);
    
    const hash = this.generateHash(content);
    
    const generated: GeneratedScript = {
      content,
      hash,
      lastModified: new Date()
    };

    // Cache the result
    this.cache.set(cacheKey, generated);
    
    // Clean old cache entries
    this.cleanCache();
    
    return generated;
  }

  /**
   * Build the complete script with proper configuration injection
   */
  private static async buildScript(config: GatekeeperConfig): Promise<string> {
    const configSection = this.generateConfigSection(config);
    const coreScript = await this.getCoreScript();

    // Simple template - no wrapper block needed (gatekeeper.js handles its own initialization)
    let template = `${this.generateHeader(config)}

${configSection}

${coreScript}

${this.generateFooter(config)}`;

    // Replace any remaining placeholders with actual values
    template = template.replace(/\{\{GATEKEEPER_CONFIG\}\}/g, 'GATEKEEPER_CONFIG');
    template = template.replace(/\{\{GATEFLOW_VERSION\}\}/g, config.version);
    template = template.replace(/\{\{ENVIRONMENT\}\}/g, config.environment);

    return template;
  }

  /**
   * Generate the configuration section with proper escaping
   */
  private static generateConfigSection(config: GatekeeperConfig): string {
    const safeConfig = {
      SUPABASE_URL: this.escapeJSString(config.supabaseUrl),
      SUPABASE_ANON_KEY: this.escapeJSString(config.supabaseAnonKey),
      GATEFLOW_VERSION: this.escapeJSString(config.version),
      ENVIRONMENT: this.escapeJSString(config.environment),
      MAIN_DOMAIN: this.escapeJSString(config.mainDomain),
      PRODUCT_SLUG: config.productSlug ? this.escapeJSString(config.productSlug) : null,
      LICENSE_VALID: config.licenseValid === true,
      FEATURES: config.features || {}
    };

    return `// === DYNAMIC CONFIGURATION ===
// Generated: ${new Date().toISOString()}
// Environment: ${config.environment}
// Version: ${config.version}

const GATEKEEPER_CONFIG = Object.freeze({
  SUPABASE_URL: '${safeConfig.SUPABASE_URL}',
  SUPABASE_ANON_KEY: '${safeConfig.SUPABASE_ANON_KEY}',
  GATEFLOW_VERSION: '${safeConfig.GATEFLOW_VERSION}',
  ENVIRONMENT: '${safeConfig.ENVIRONMENT}',
  MAIN_DOMAIN: '${safeConfig.MAIN_DOMAIN}',
  PRODUCT_SLUG: ${safeConfig.PRODUCT_SLUG ? `'${safeConfig.PRODUCT_SLUG}'` : 'null'},
  LICENSE_VALID: ${safeConfig.LICENSE_VALID},
  FEATURES: ${JSON.stringify(safeConfig.FEATURES, null, 2)},
  BUILD_TIME: '${new Date().toISOString()}',
  BUILD_HASH: '${this.generateBuildHash(config)}'
});`;
  }

  /**
   * Generate script header with metadata
   */
  private static generateHeader(config: GatekeeperConfig): string {
    return `/*!
 * GateKeeper.js v${config.version}
 * Generated by GateFlow Admin Panel
 * 
 * Build: ${new Date().toISOString()}
 * Environment: ${config.environment}
 * Features: ${Object.keys(config.features || {}).join(', ') || 'default'}
 * 
 * @license Freemium - Free with watermark, paid license removes watermark
 * @website https://gateflow.pl
 * @support support@gateflow.pl
 */

'use strict';`;
  }

  /**
   * Get the core script content (the actual gatekeeper logic)
   */
  private static async getCoreScript(): Promise<string> {
    const { readFileSync } = await import('fs');
    const { join } = await import('path');
    
    try {
      const gatekeeperPath = join(process.cwd(), '../gatekeeper.js');
      let content = readFileSync(gatekeeperPath, 'utf-8');
      
      // Use template approach - replace specific placeholders
      content = this.processTemplate(content);
      
      return content;
    } catch (error: unknown) {
      console.warn('gatekeeper.js not found, using fallback:', error);
      // Fallback to inline core script if file not found
      return this.getInlineCoreScript();
    }
  }

  /**
   * Process template placeholders in the core script
   */
  private static processTemplate(content: string): string {
    // Remove the main file header comment block (only at the very beginning)
    content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    
    // The core script should now be clean without configuration blocks
    return content.trim();
  }

  /**
   * Fallback inline core script
   */
  private static getInlineCoreScript(): string {
    return `
// Core GateKeeper functionality will be loaded here
// This is a fallback when gatekeeper-core.js is not found

// Clean implementation for development
window.gatekeeper = {
  config: GATEKEEPER_CONFIG,
  
  init: function() {
    console.log('GateKeeper initialized in fallback mode');
  },
  
  checkAccess: function(productSlug) {
    return Promise.resolve(false);
  },
  
  getConfig: function(key) {
    return key ? GATEKEEPER_CONFIG[key] : GATEKEEPER_CONFIG;
  }
};
`;
  }

  /**
   * Generate footer code (no wrapper block needed)
   */
  private static generateFooter(config: GatekeeperConfig): string {
    return `
// Make config available globally for debugging
if (typeof GATEKEEPER_CONFIG !== 'undefined') {
  window.GATEKEEPER_CONFIG = GATEKEEPER_CONFIG;
  if (GATEKEEPER_CONFIG.ENVIRONMENT === 'development') {
    console.log('[GateFlow] Config loaded:', GATEKEEPER_CONFIG.GATEFLOW_VERSION);
  }
}
`;
  }

  /**
   * Escape string for safe JavaScript injection
   */
  private static escapeJSString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"')
      .replace(/\r/g, '\\r')
      .replace(/\n/g, '\\n')
      .replace(/\t/g, '\\t');
  }

  /**
   * Generate cache key for configuration
   */
  private static getCacheKey(config: GatekeeperConfig): string {
    const key = `${config.supabaseUrl}_${config.environment}_${config.version}_${config.productSlug || 'default'}_${config.licenseValid || false}_${JSON.stringify(config.features)}`;
    return this.generateHash(key);
  }

  /**
   * Generate hash for content or cache key
   */
  private static generateHash(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  /**
   * Generate build hash from configuration
   */
  private static generateBuildHash(config: GatekeeperConfig): string {
    const hashInput = `${config.supabaseUrl}_${config.version}_${Date.now()}`;
    return this.generateHash(hashInput).substring(0, 8);
  }

  /**
   * Check if cached script is still valid
   */
  private static isCacheValid(cached: GeneratedScript): boolean {
    const age = Date.now() - cached.lastModified.getTime();
    return age < this.CACHE_TTL;
  }

  /**
   * Clean expired cache entries
   */
  private static cleanCache(): void {
    const now = Date.now();
    for (const [key, cached] of this.cache.entries()) {
      const age = now - cached.lastModified.getTime();
      if (age > this.CACHE_TTL) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Get cache statistics for monitoring
   */
  static getCacheStats() {
    return {
      size: this.cache.size,
      entries: Array.from(this.cache.keys()),
      lastCleanup: new Date()
    };
  }

  /**
   * Clear all cache (useful for development)
   */
  static clearCache(): void {
    this.cache.clear();
  }
}
